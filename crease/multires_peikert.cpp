// STL
#include <cmath>
#include <array>
#include <exception>
#include <algorithm>
#include <utility>
#include <fstream>
#include <regex>
#include <map>
// Boost
#include <boost/math/interpolators/cardinal_cubic_b_spline.hpp>
#include <boost/multi_array.hpp>
// Eigen
#include <Eigen/Eigen>
// Teem
#include <teem/nrrd.h>
// spurt
#include <misc/option_parse.hpp>
#include <image/nrrd_wrapper.hpp>
#include <misc/progress.hpp>
#include <spline/spline.h>

#include <vtkDoubleArray.h>
#include <vtkCellArray.h>
#include <vtkPoints.h>
#include <vtkPolyData.h>
#include <vtkXMLPolyDataWriter.h>
#include <vtkPointData.h>

// idea:
// 1. Use Peikert's determinant idea to find ridge pouints along edges
// 2. Do no rely on linear variation of the determinant, instead
//    2a. Sample determinant along edge 
//    2b. Fit a cubic spline to those samples
//    2c. Find possible local extrema in between samples that could correspond to zero crossings
//    2d. Compute zero crossings
// 3. Check for MC configuration corresponding to found edges
// 4. If no MC case or multiple ridge pouints per edge, mark for subdivision
// 5. For each subdivision voxel, go back to 1.

typedef unsigned int uint;

uint verbose = 1;

constexpr int criterion_underflow = -10;
constexpr int determinant_underflow = -20;
constexpr int weak_ridge = -30;
constexpr int low_ridge = -40;
constexpr int several_ridge_points = -50;
constexpr int no_ridge_point = -1;
constexpr int unknown_error = -100;
constexpr int one_ridge_point = 0;

constexpr int one_triangle = 1;
constexpr int valid_mc_case = 2;
constexpr int invalid_mc_case = 3;
constexpr int exotic_case = 4;
constexpr int not_enough_edges = 5;

typedef Eigen::Matrix<uint, 3, 1> coord3;
typedef Eigen::Matrix<double, 3, 1> vec3;
typedef Eigen::Matrix<double, 4, 1> vec4;
typedef Eigen::Matrix<double, 3, 3> mat3;
typedef Eigen::Matrix<uint, Eigen::Dynamic, Eigen::Dynamic> dyn_mat_type;
typedef Eigen::SelfAdjointEigenSolver<mat3> eigensolver_type;
typedef boost::multi_array<double, 3> scalar_raster;
typedef boost::multi_array<vec3, 3> vector_raster;
typedef boost::multi_array<mat3, 3> matrix_raster;

struct Less
{
    bool operator()(const coord3& a, const coord3& b) const
    {
        if (a[0] < b[0]) return true;
        else if (b[0] < a[0]) return false;
        else if (a[1] < b[1]) return true;
        else if (b[1] < a[1]) return false;
        else return a[2] < b[2];
    }
};


struct PosLexico
{
    static constexpr double eps = 1.0e-9;
    bool operator()(const vec3& p0, const vec3& p1) const
    {
        if (p0[0] < p1[0]-eps)
            return true;
        else if (p1[0] < p0[0]-eps)
            return false;
        else if (p0[1] < p1[1]-eps)
            return true;
        else if (p1[1] < p0[1]-eps)
            return false;
        else
            return p0[2] < p1[2]-eps;
    }
};

constexpr double invalid = std::numeric_limits<double>::max();

uint vertices[][3] = { {0, 0, 0}, {1, 0, 0}, {1, 1, 0}, {0, 1, 0 },
                { 0, 0, 1 }, { 1, 0, 1 }, { 1, 1, 1 }, { 0, 1, 1 } };

uint edges[][4] = { { 0, 2, 4, 6 }, { 3, 7, 1, 5 }, { 8, 9, 11, 10 } };

uint canonical_edge_coordinates[][2][3] = 
        { {{ 0, 0, 0 }, { 1, 0, 0 }}, // 0
          {{ 1, 0, 0 }, { 1, 1, 0 }}, // 1
          {{ 0, 1, 0 }, { 1, 1, 0 }}, // 2 
          {{ 0, 0, 0 }, { 0, 1, 0 }}, // 3
          {{ 0, 0, 1 }, { 1, 0, 1 }}, // 4
          {{ 1, 0, 1 }, { 1, 1, 1 }}, // 5
          {{ 0, 1, 1 }, { 1, 1, 1 }}, // 6
          {{ 0, 0, 1 }, { 0, 1, 1 }}, // 7
          {{ 0, 0, 0 }, { 0, 0, 1 }}, // 8
          {{ 1, 0, 0 }, { 1, 0, 1 }}, // 9
          {{ 1, 1, 0 }, { 1, 1, 1 }}, // 10
          {{ 0, 1, 0 }, { 0, 1, 1 }} }; // 11

uint canonical_edge_indices[][2] = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, 
    {4, 5}, {5, 6}, {6, 7}, {7, 4},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}
};

char triTable[256][16] ={
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 0
     {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 1
     {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 2
     {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 3
     {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 4
     {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 5
     {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 6
     {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},        // 7
     {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 8
     {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 9
     {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 10
     {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},       // 11
     {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 12
     {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 13
     {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},       // 14
     {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 15
     {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 16
     {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 17
     {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 18
     {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},          // 19
     {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 20
     {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},         // 21
     {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},         // 22
     {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},            // 23
     {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 24
     {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},        // 25
     {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},         // 26
     {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},          // 27
     {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},       // 28 
     {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},         // 29
     {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},         // 30
     {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 31
     {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 32
     {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 33
     {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 34
     {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},          // 35
     {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 36
     {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},         // 37
     {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},         // 38
     {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},            // 39
     {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 40
     {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
     {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
     {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},          // 45
     {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
     {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},          // 50
     {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
     {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
     {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},         // 55
     {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
     {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},          // 60
     {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
     {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
     {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 65
     {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
     {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},          // 70
     {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},          // 75
     {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
     {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 80
     {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
     {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},             // 85
     {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
     {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
     {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},           // 90
     {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
     {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
     {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
     {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},           // 95
     {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
     {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},          // 100     
     {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
     {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},          // 105
     {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
     {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
     {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
     {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},         // 110
     {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
     {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
     {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},        // 115 
     {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
     {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
     {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
     {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},          // 120
     {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
     {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
     {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
     {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
     {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 125
     {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
     {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 130
     {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},         // 135
     {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
     {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},        // 140
     {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
     {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
     {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
     {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},         // 145
     {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
     {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
     {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
     {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},          // 150
     {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
     {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
     {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
     {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},          // 155
     {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
     {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
     {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 160
     {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
     {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},           // 165
     {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
     {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
     {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
     {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},             // 170
     {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
     {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
     {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
     {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
     {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},         // 175
     {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
     {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
     {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},         // 180
     {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
     {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
     {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
     {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
     {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},          // 185
     {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
     {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
     {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
     {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 190
     {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
     {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
     {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},          // 195
     {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
     {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
     {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
     {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},         // 200
     {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
     {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
     {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
     {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},          // 205
     {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
     {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
     {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},         // 210
     {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
     {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
     {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
     {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
     {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 215
     {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
     {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
     {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},          // 220
     {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
     {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},          // 225
     {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
     {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
     {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
     {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
     {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},        // 230
     {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
     {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
     {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
     {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
     {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 235
     {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
     {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 240
     {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},           // 245
     {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},           // 250
     {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};// 255

int edge_code_to_case_id[4096] = {
255, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 0 - 9
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 10 - 19
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 20 - 29
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 30 - 39
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 40 - 49
-1, 221, -1, -1, -1, -1, -1, -1, -1, -1,  // 50 - 59
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 60 - 69
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 70 - 79
-1, -1, -1, -1, -1, 153, -1, -1, -1, -1,  // 80 - 89
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 90 - 99
-1, -1, 187, -1, -1, -1, -1, -1, -1, -1,  // 100 - 109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 110 - 119
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 120 - 129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 130 - 139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 140 - 149
-1, -1, -1, 238, -1, -1, -1, -1, -1, -1,  // 150 - 159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 160 - 169
204, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 170 - 179
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 180 - 189
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 190 - 199
-1, -1, -1, -1, 136, -1, -1, -1, -1, -1,  // 200 - 209
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 210 - 219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 220 - 229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 230 - 239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 240 - 249
-1, -1, -1, -1, -1, 170, -1, -1, -1, -1,  // 250 - 259
-1, -1, -1, -1, -1, 254, -1, -1, -1, -1,  // 260 - 269
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 270 - 279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 280 - 289
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 290 - 299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 300 - 309
-1, -1, -1, -1, 220, -1, -1, -1, -1, -1,  // 310 - 319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 320 - 329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 330 - 339
-1, -1, -1, -1, -1, -1, -1, -1, 152, -1,  // 340 - 349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 350 - 359
-1, -1, -1, -1, -1, -1, -1, 186, -1, -1,  // 360 - 369
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 370 - 379
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 380 - 389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 390 - 399
239, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 400 - 409
-1, -1, -1, -1, -1, -1, -1, -1, -1, 205,  // 410 - 419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 420 - 429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 430 - 439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 440 - 449
-1, -1, -1, 137, -1, -1, -1, -1, -1, -1,  // 450 - 459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 460 - 469
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 470 - 479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 480 - 489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 490 - 499
-1, -1, 171, -1, -1, -1, -1, -1, -1, -1,  // 500 - 509
-1, -1, -1, -1, -1, 253, -1, -1, -1, -1,  // 510 - 519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 520 - 529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 530 - 539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 540 - 549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 550 - 559
223, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 560 - 569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 570 - 579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 580 - 589
-1, -1, -1, -1, -1, -1, -1, -1, 155, -1,  // 590 - 599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 600 - 609
-1, -1, -1, 185, -1, -1, -1, -1, -1, -1,  // 610 - 619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 620 - 629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 630 - 639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 640 - 649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 650 - 659
-1, -1, -1, -1, -1, -1, 236, -1, -1, -1,  // 660 - 669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 670 - 679
-1, 206, -1, -1, -1, -1, -1, -1, -1, -1,  // 680 - 689
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 690 - 699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 700 - 709
-1, -1, -1, -1, -1, -1, -1, -1, -1, 138,  // 710 - 719
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 720 - 729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 730 - 739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 740 - 749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 750 - 759
-1, -1, -1, -1, 168, -1, -1, -1, -1, -1,  // 760 - 769
-1, -1, -1, -1, -1, -1, -1, -1, 252, -1,  // 770 - 779
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 780 - 789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 790 - 799
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 800 - 809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 810 - 819
-1, -1, -1, -1, -1, 222, -1, -1, -1, -1,  // 820 - 829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 830 - 839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 840 - 849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 850 - 859
-1, -1, -1, 154, -1, -1, -1, -1, -1, -1,  // 860 - 869
-1, -1, -1, -1, -1, -1, 184, -1, -1, -1,  // 870 - 879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 880 - 889
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 890 - 899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 900 - 909
-1, -1, -1, -1, -1, 237, -1, -1, -1, -1,  // 910 - 919
-1, -1, -1, -1, -1, -1, -1, -1, 207, -1,  // 920 - 929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 930 - 939
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 940 - 949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 950 - 959
-1, -1, -1, -1, -1, -1, 139, -1, -1, -1,  // 960 - 969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 970 - 979
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 980 - 989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 990 - 999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1000 - 1009
-1, -1, -1, 169, -1, -1, -1, -1, -1, -1,  // 1010 - 1019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1020 - 1029
251, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1030 - 1039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1040 - 1049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1050 - 1059
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1060 - 1069
-1, -1, -1, -1, -1, -1, -1, 217, -1, -1,  // 1070 - 1079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1080 - 1089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1090 - 1099
-1, -1, -1, -1, -1, -1, -1, 157, -1, -1,  // 1100 - 1109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1110 - 1119
191, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1120 - 1129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1130 - 1139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1140 - 1149
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1150 - 1159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1160 - 1169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1170 - 1179
-1, -1, -1, 234, -1, -1, -1, -1, -1, -1,  // 1180 - 1189
-1, -1, -1, -1, -1, -1, 200, -1, -1, -1,  // 1190 - 1199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1200 - 1209
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1210 - 1219
-1, -1, -1, -1, -1, -1, 140, -1, -1, -1,  // 1220 - 1229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1230 - 1239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1240 - 1249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1250 - 1259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1260 - 1269
-1, -1, -1, 174, -1, -1, -1, -1, -1, -1,  // 1270 - 1279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1280 - 1289
-1, -1, -1, -1, -1, 250, -1, -1, -1, -1,  // 1290 - 1299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1300 - 1309
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1310 - 1319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1320 - 1329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1330 - 1339
216, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1340 - 1349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1350 - 1359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1360 - 1369
156, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1370 - 1379
-1, -1, -1, -1, -1, 190, -1, -1, -1, -1,  // 1380 - 1389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1390 - 1399
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1400 - 1409
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1410 - 1419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1420 - 1429
235, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1430 - 1439
-1, -1, -1, -1, -1, 201, -1, -1, -1, -1,  // 1440 - 1449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1450 - 1459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1460 - 1469
-1, -1, -1, -1, -1, 141, -1, -1, -1, -1,  // 1470 - 1479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1480 - 1489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1490 - 1499
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1500 - 1509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1510 - 1519
175, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1520 - 1529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1530 - 1539
-1, 249, -1, -1, -1, -1, -1, -1, -1, -1,  // 1540 - 1549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1550 - 1559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1560 - 1569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1570 - 1579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1580 - 1589
219, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1590 - 1599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1600 - 1609
-1, -1, -1, -1, -1, -1, 159, -1, -1, -1,  // 1610 - 1619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1620 - 1629
-1, -1, -1, -1, -1, 189, -1, -1, -1, -1,  // 1630 - 1639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1640 - 1649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1650 - 1659
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1660 - 1669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1670 - 1679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1680 - 1689
-1, -1, 232, -1, -1, -1, -1, -1, -1, -1,  // 1690 - 1699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1700 - 1709
-1, 202, -1, -1, -1, -1, -1, -1, -1, -1,  // 1710 - 1719
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1720 - 1729
-1, -1, -1, -1, -1, -1, -1, 142, -1, -1,  // 1730 - 1739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1740 - 1749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1750 - 1759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1760 - 1769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1770 - 1779
-1, -1, -1, -1, -1, -1, 172, -1, -1, -1,  // 1780 - 1789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1790 - 1799
-1, -1, -1, -1, 248, -1, -1, -1, -1, -1,  // 1800 - 1809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1810 - 1819
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1820 - 1829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1830 - 1839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1840 - 1849
-1, -1, -1, -1, -1, 218, -1, -1, -1, -1,  // 1850 - 1859
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1860 - 1869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1870 - 1879
-1, 158, -1, -1, -1, -1, -1, -1, -1, -1,  // 1880 - 1889
-1, -1, -1, -1, -1, -1, -1, -1, 188, -1,  // 1890 - 1899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1900 - 1909
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1910 - 1919
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1920 - 1929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1930 - 1939
-1, 233, -1, -1, -1, -1, -1, -1, -1, -1,  // 1940 - 1949
-1, -1, -1, -1, -1, -1, -1, -1, 203, -1,  // 1950 - 1959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1960 - 1969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1970 - 1979
-1, -1, -1, -1, 143, -1, -1, -1, -1, -1,  // 1980 - 1989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1990 - 1999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2000 - 2009
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2010 - 2019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2020 - 2029
-1, -1, -1, -1, -1, 173, -1, -1, -1, -1,  // 2030 - 2039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2040 - 2049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2050 - 2059
247, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2060 - 2069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2070 - 2079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2080 - 2089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2090 - 2099
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2100 - 2109
-1, 213, -1, -1, -1, -1, -1, -1, -1, -1,  // 2110 - 2119
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2120 - 2129
-1, -1, -1, -1, -1, -1, -1, 145, -1, -1,  // 2130 - 2139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2140 - 2149
-1, -1, -1, -1, 179, -1, -1, -1, -1, -1,  // 2150 - 2159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2160 - 2169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2170 - 2179
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2180 - 2189
-1, -1, -1, -1, -1, -1, -1, 230, -1, -1,  // 2190 - 2199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2200 - 2209
-1, -1, -1, -1, 196, -1, -1, -1, -1, -1,  // 2210 - 2219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2220 - 2229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2230 - 2239
128, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2240 - 2249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2250 - 2259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2260 - 2269
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2270 - 2279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2280 - 2289
-1, 162, -1, -1, -1, -1, -1, -1, -1, -1,  // 2290 - 2299
-1, -1, -1, -1, -1, -1, -1, -1, -1, 246,  // 2300 - 2309
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2310 - 2319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2320 - 2329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2330 - 2339
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2340 - 2349
-1, -1, -1, -1, -1, -1, -1, -1, 212, -1,  // 2350 - 2359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2360 - 2369
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2370 - 2379
-1, -1, -1, -1, 144, -1, -1, -1, -1, -1,  // 2380 - 2389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2390 - 2399
-1, -1, -1, 178, -1, -1, -1, -1, -1, -1,  // 2400 - 2409
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2410 - 2419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2420 - 2429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2430 - 2439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2440 - 2449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2450 - 2459
231, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2460 - 2469
-1, -1, -1, -1, -1, -1, -1, -1, -1, 197,  // 2470 - 2479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2480 - 2489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2490 - 2499
-1, -1, -1, -1, -1, 129, -1, -1, -1, -1,  // 2500 - 2509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2510 - 2519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2520 - 2529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2530 - 2539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2540 - 2549
-1, -1, -1, -1, 163, -1, -1, -1, -1, -1,  // 2550 - 2559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2560 - 2569
-1, -1, -1, -1, -1, 245, -1, -1, -1, -1,  // 2570 - 2579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2580 - 2589
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2590 - 2599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2600 - 2609
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2610 - 2619
215, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2620 - 2629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2630 - 2639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2640 - 2649
147, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2650 - 2659
-1, -1, -1, -1, -1, 177, -1, -1, -1, -1,  // 2660 - 2669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2670 - 2679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2680 - 2689
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2690 - 2699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2700 - 2709
228, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2710 - 2719
-1, -1, -1, -1, -1, 198, -1, -1, -1, -1,  // 2720 - 2729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2730 - 2739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2740 - 2749
-1, -1, -1, -1, -1, 130, -1, -1, -1, -1,  // 2750 - 2759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2760 - 2769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2770 - 2779
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2780 - 2789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2790 - 2799
160, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2800 - 2809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2810 - 2819
-1, -1, 244, -1, -1, -1, -1, -1, -1, -1,  // 2820 - 2829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2830 - 2839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2840 - 2849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2850 - 2859
-1, -1, -1, -1, -1, -1, -1, -1, -1, 214,  // 2860 - 2869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2870 - 2879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2880 - 2889
-1, -1, -1, -1, -1, -1, -1, -1, -1, 146,  // 2890 - 2899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2900 - 2909
-1, -1, 176, -1, -1, -1, -1, -1, -1, -1,  // 2910 - 2919
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2920 - 2929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2930 - 2939
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2940 - 2949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2950 - 2959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2960 - 2969
-1, -1, -1, -1, -1, 229, -1, -1, -1, -1,  // 2970 - 2979
-1, -1, -1, -1, -1, -1, -1, -1, 199, -1,  // 2980 - 2989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2990 - 2999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3000 - 3009
-1, -1, -1, -1, -1, -1, -1, -1, 131, -1,  // 3010 - 3019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3020 - 3029
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3030 - 3039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3040 - 3049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3050 - 3059
-1, -1, -1, -1, -1, 161, -1, -1, -1, -1,  // 3060 - 3069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3070 - 3079
-1, -1, 243, -1, -1, -1, -1, -1, -1, -1,  // 3080 - 3089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3090 - 3099
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3100 - 3109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3110 - 3119
-1, -1, -1, -1, -1, -1, -1, -1, -1, 209,  // 3120 - 3129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3130 - 3139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3140 - 3149
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3150 - 3159
-1, -1, -1, -1, -1, -1, -1, 149, -1, -1,  // 3160 - 3169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3170 - 3179
183, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3180 - 3189
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3190 - 3199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3200 - 3209
-1, -1, -1, -1, -1, -1, -1, -1, -1, 226,  // 3210 - 3219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3220 - 3229
-1, -1, 192, -1, -1, -1, -1, -1, -1, -1,  // 3230 - 3239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3240 - 3249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3250 - 3259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3260 - 3269
132, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3270 - 3279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3280 - 3289
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3290 - 3299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3300 - 3309
-1, -1, -1, -1, -1, -1, -1, 166, -1, -1,  // 3310 - 3319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3320 - 3329
-1, 242, -1, -1, -1, -1, -1, -1, -1, -1,  // 3330 - 3339
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3340 - 3349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3350 - 3359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3360 - 3369
-1, -1, -1, -1, -1, -1, 208, -1, -1, -1,  // 3370 - 3379
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3380 - 3389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3390 - 3399
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3400 - 3409
-1, -1, -1, -1, 148, -1, -1, -1, -1, -1,  // 3410 - 3419
-1, -1, -1, -1, -1, -1, -1, -1, -1, 182,  // 3420 - 3429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3430 - 3439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3440 - 3449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3450 - 3459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3460 - 3469
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3470 - 3479
-1, -1, 227, -1, -1, -1, -1, -1, -1, -1,  // 3480 - 3489
-1, -1, -1, -1, -1, -1, -1, 193, -1, -1,  // 3490 - 3499
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3500 - 3509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3510 - 3519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3520 - 3529
-1, -1, -1, -1, -1, 133, -1, -1, -1, -1,  // 3530 - 3539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3540 - 3549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3550 - 3559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3560 - 3569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3570 - 3579
167, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3580 - 3589
-1, -1, -1, 241, -1, -1, -1, -1, -1, -1,  // 3590 - 3599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3600 - 3609
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3610 - 3619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3620 - 3629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3630 - 3639
-1, -1, 211, -1, -1, -1, -1, -1, -1, -1,  // 3640 - 3649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3650 - 3659
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3660 - 3669
-1, -1, -1, -1, -1, -1, 151, -1, -1, -1,  // 3670 - 3679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3680 - 3689
-1, -1, -1, -1, -1, 181, -1, -1, -1, -1,  // 3690 - 3699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3700 - 3709
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3710 - 3719
-1, -1, -1, -1, -1, -1, -1, -1, 224, -1,  // 3720 - 3729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3730 - 3739
-1, -1, -1, -1, -1, -1, -1, 194, -1, -1,  // 3740 - 3749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3750 - 3759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3760 - 3769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3770 - 3779
-1, 134, -1, -1, -1, -1, -1, -1, -1, -1,  // 3780 - 3789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3790 - 3799
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3800 - 3809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3810 - 3819
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3820 - 3829
164, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3830 - 3839
240, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3840 - 3849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3850 - 3859
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3860 - 3869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3870 - 3879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3880 - 3889
-1, 210, -1, -1, -1, -1, -1, -1, -1, -1,  // 3890 - 3899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3900 - 3909
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3910 - 3919
-1, -1, -1, -1, -1, 150, -1, -1, -1, -1,  // 3920 - 3929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3930 - 3939
-1, -1, 180, -1, -1, -1, -1, -1, -1, -1,  // 3940 - 3949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3950 - 3959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3960 - 3969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3970 - 3979
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3980 - 3989
-1, -1, -1, 225, -1, -1, -1, -1, -1, -1,  // 3990 - 3999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4000 - 4009
195, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 4010 - 4019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4020 - 4029
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4030 - 4039
-1, -1, -1, -1, 135, -1, -1, -1, -1, -1,  // 4040 - 4049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4050 - 4059
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4060 - 4069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4070 - 4079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4080 - 4089
-1, -1, -1, -1, -1, 165 }; // 4090 - 4095

// Voxel encapsulates all info needed to compute ridge pouints and surfaces in a voxel
class Voxel
{
private:
    static uint c2id(uint i, uint j, uint k)
    {
        return i + 2 * (j + 2 * k);
    }
    static coord3 id2c(uint n)
    {
        if (n < 0 || n > 7)
        {
            throw std::runtime_error("Invalid index in Voxel::id2c");
        }
        auto qr = std::div(n, 4);
        uint k = qr.quot;
        auto qr2 = std::div(qr.rem, 2);
        uint j = qr2.quot;
        uint i = qr2.rem;
        return coord3(i, j, k);
    }

public:
    struct VertexInfo
    {
        coord3 coord;
        vec3 pos;
        double value;
        vec3 gradient;
        mat3 hessian;
    };

    Voxel() : m_min(-1, -1, -1), m_max(0, 0, 0), coord(0, 0, 0) {}
    
    const double &value(uint i, uint j, uint k) const
    { 
        return values[c2id(i,j,k)];
    }
    
    // Value lookup
    double &value(uint i, uint j, uint k)
    {
        return const_cast<double&>(static_cast<const Voxel&>(*this).value(i, j, k));
    }
    
    const double& value(uint n) const
    {
        if (n>7)
        {
            throw std::runtime_error("Invalid index in Voxel::value(uint)");
        }
        return values[n];
    }
    
    double &value(uint n)
    {
        return const_cast<double&>(static_cast<const Voxel&>(*this).value(n));
    }
    
    // Gradient lookup
    const vec3& gradient(uint i, uint j, uint k) const
    { 
        return gradients[i + 2 * (j + 2 * k)];
    }
    
    vec3 &gradient(uint i, uint j, uint k)
    {
        return const_cast<vec3 &>(static_cast<const Voxel &>(*this).gradient(i,j,k));
    }
    
    const vec3& gradient(uint n) const
    {
        if (n>7)
        {
            throw std::runtime_error("Invalid index in Voxel::gradient(uint)");
        }
        return gradients[n];
    }
    
    vec3& gradient(uint n)
    {
        return const_cast<vec3 &>(static_cast<const Voxel &>(*this).gradient(n));
    }
    
    // Hessian lookup
    const mat3 &hessian(uint i, uint j, uint k) const
    {
        return hessians[i + 2 * (j + 2 * k)];
    }
    
    mat3 &hessian(uint i, uint j, uint k) 
    {
        return const_cast<mat3 &>(static_cast<const Voxel &>(*this).hessian(i,j,k));
    }
    
    const mat3 &hessian(uint n) const
    {
        if (n>7)
        {
            throw std::runtime_error("Invalid index in Voxel::hessian(uint)");
        }
        return hessians[n];
    }
    
    mat3& hessian(uint n)
    {
        return const_cast<mat3 &>(static_cast<const Voxel &>(*this).hessian(n));
    }

    // Vertices
    VertexInfo vertex_info(uint i, uint j, uint k) const
    {
        VertexInfo vinfo;
        vinfo.coord = coord + coord3(i,j,k);
        vec3 p = m_min;
        if (i==1) p[0] = m_max[0];
        if (j==1) p[1] = m_max[1];
        if (k==1) p[2] = m_max[2];
        vinfo.pos = p;
        vinfo.value = this->value(i,j,k);
        vinfo.gradient = this->gradient(i,j,k);
        vinfo.hessian = this->hessian(i,j,k);

        return vinfo;
    }

    VertexInfo vertex_info(uint n) const 
    {
        if (n > 7)
        {
            throw std::runtime_error("Invalid index in Voxel::vertex_info(uint)");
        }
        coord3 c = Voxel::id2c(n);
        return this->vertex_info(c[0], c[1], c[2]);
    }

    // Edges
    std::pair<VertexInfo, VertexInfo> edge_info(uint n) const
    {
        if (n > 11)
        {
            throw std::runtime_error("Invalid index in Voxel::edge_info(uint)");
        }
        uint i0 = canonical_edge_indices[n][0];
        uint i1 = canonical_edge_indices[n][1];
        auto v0 = this->vertex_info(i0);
        auto v1 = this->vertex_info(i1);
        return std::make_pair(v0, v1);
    }

    void set_bounds(const vec3& min, const vec3& max)
    {
        m_min = min;
        m_max = max;
    }

    std::pair<vec3, vec3> get_bounds() const
    {
        return std::make_pair(m_min, m_max);
    }

    vec3 m_min, m_max;
    coord3 coord;
    std::array<double, 8> values;
    std::array<vec3, 8> gradients;
    std::array<mat3, 8> hessians;
};

template<typename V>
struct ValueFiller {};

template<>
struct ValueFiller<double> {
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    double operator()(const wrapper_type& w, size_t i, size_t stride) {
        return w[i];
    }
};

template<>
struct ValueFiller<vec3> {
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    vec3 operator()(const wrapper_type& w, size_t i, size_t stride) {
        return vec3(w[i], w[i+stride], w[i+2*stride]);
    } 
};

template <>
struct ValueFiller<mat3>
{
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    mat3 operator()(const wrapper_type &w, size_t i, size_t stride)
    {
        return mat3({ {w[i],          w[i+stride],   w[i+2*stride]},
                      {w[i+3*stride], w[i+4*stride], w[i+5*stride]},
                      {w[i+6*stride], w[i+7*stride], w[i+8*stride]} });
    }
};

// A simple raster dataset class to wrap a NRRD dataset
template<typename T=double, typename V=T, typename Filler=ValueFiller<V> >
struct BlockOfValues {
    typedef T scalar_type;
    typedef V value_type;
    typedef spurt::nrrd_utils::nrrd_data_wrapper<T> wrapper_type;
    typedef BlockOfValues<scalar_type, value_type> self_type;
    typedef Filler filler_type;

    static bool check_cell_coordinates(const coord3& c, const coord3& sizes) 
    {
        return c[0] < sizes[0]-1 &&
               c[1] < sizes[1]-1 &&
               c[2] < sizes[2]-1;
    }

    static bool check_vertex_coordinates(const coord3 &c, const coord3 &sizes)
    {
        return c[0] < sizes[0] &&
               c[1] < sizes[1] &&
               c[2] < sizes[2];
    }

    BlockOfValues() : m_sizes(), m_data() {}

    BlockOfValues(Nrrd *nin)
    {
        wrapper_type wrap(nin);
        bool is_scalar = (nin->dim == 3);

        // figure out how the data is stored
        uint outerstride = 1;
        uint innerstride = 1;
        uint spacemin=0;
        if (!is_scalar) {
            if (nin->dim == 4) {
                if (nin->axis[0].size <= 9) {
                    // individual scalar entries are in innermost dim
                    spacemin = 1;
                    outerstride = nin->axis[0].size;
                    innerstride = 1;
                }
                else if (nin->axis[3].size <= 9) {
                    // individual scalar entries are in outermost dim
                    spacemin = 0;
                    innerstride = nin->axis[0].size*nin->axis[1].size*nin->axis[2].size;
                    outerstride = 1;
                }
                else {
                    throw std::runtime_error("Unrecognized Nrrd shape in BlockOfValues::BlockOfValues");
                }
            }
            else if (nin->dim == 5) {
                if (nin->axis[0].size*nin->axis[1].size <= 9) {
                    // individual scalar entries are in innermost dim
                    spacemin = 2;
                    outerstride = nin->axis[0].size*nin->axis[1].size;
                    innerstride = 1;
                }
                else if (nin->axis[3].size*nin->axis[4].size <= 9) {
                    // individual scalar entries are in outermost dim
                    spacemin = 0;
                    innerstride = nin->axis[0].size*nin->axis[1].size*nin->axis[2].size;
                    outerstride = 1;
                }
                else {
                    throw std::runtime_error("Unrecognized Nrrd shape in BlockOfValues::BlockOfValues");
                }
            }
        }
        m_sizes = { nin->axis[spacemin].size, 
                    nin->axis[spacemin+1].size, 
                    nin->axis[spacemin+2].size };
        m_origin = vec3(0,0,0);
        m_spacings = vec3(1,1,1);
        for (uint d=0; d<3; ++d)
        {
            if (!std::isnan(nin->axis[spacemin+d].min))
            {
                m_origin[d] = nin->axis[spacemin+d].min;
            }
            if (!std::isnan(nin->axis[spacemin+d].spacing))
            {
                m_spacings[d] = nin->axis[spacemin+d].spacing;
            }
        }
        size_t nvalues = m_sizes[0] * m_sizes[1] * m_sizes[2];

        m_data.resize(nvalues);
        filler_type filler;
        for (size_t i=0; i<nvalues; ++i) {
            size_t idx = outerstride*i;
            m_data[i] = filler(wrap, idx, innerstride);
        }
    }

    self_type& operator=(const self_type& other) {
        m_sizes = other.m_sizes;
        m_data = other.m_data;
        m_spacings = other.m_spacings;
        m_origin = other.m_origin;
        return *this;
    }

    const value_type &operator()(uint i, uint j, uint k) const
    {
        if (!self_type::check_vertex_coordinates(coord3(i,j,k), m_sizes))
            throw std::runtime_error("Invalid coordinates in BlockOfValues::access");
        return m_data[i + m_sizes[0] * (j + m_sizes[1] * k)];
    }

    value_type &operator()(uint i, uint j, uint k)
    {
        return const_cast<value_type&>(static_cast<const self_type &>(*this)(i,j,k));
    }

    const value_type& operator()(const coord3& c) const
    {
        return (*this)(c[0], c[1], c[2]);
    }

    value_type& operator()(const coord3& c)
    {
        return const_cast<value_type &>(static_cast<const self_type &>(*this)(c));
    }

    // uinterpolate in a specified voxel at given local coordinates
    value_type uinterpolate(const coord3& ic, double u, double v, double w) const
    {
        return (1. - u) * (1. - v) * (1. - w) * (*this)(ic[0], ic[1], ic[2]) +
               u * (1. - v) * (1. - w) * (*this)(ic[0] + 1, ic[1], ic[2]) +
               u * v * (1. - w) * (*this)(ic[0] + 1, ic[1] + 1, ic[2]) +
               (1. - u) * v * (1. - w) * (*this)(ic[0], ic[1] + 1, ic[2]) +
               (1. - u) * (1. - v) * w * (*this)(ic[0], ic[1], ic[2] + 1) +
               u * (1. - v) * w * (*this)(ic[0] + 1, ic[1], ic[2] + 1) +
               u * v * w * (*this)(ic[0] + 1, ic[1] + 1, ic[2] + 1) +
               (1. - u) * v * w * (*this)(ic[0], ic[1] + 1, ic[2] + 1);
    }

    // uinterpolate at a global position p
    value_type evaluate(const vec3& p, bool world=true) const
    {
        vec3 q;
        if (world)
        { 
            // convert to local (fractional) index coordinates
            q = p - m_origin;
            q = (q.array() / m_spacings.array()).matrix();
        }
        else q = p;
        coord3 cellid = q.cast<uint>();
        for (uint d = 0; d < 3; ++d)
        {
            cellid[d] = std::min<uint>(cellid[d], m_sizes[d] - 2);
        }

        double u = q[0] - cellid[0];
        double v = q[1] - cellid[1];
        double w = q[2] - cellid[2];
        return this->uinterpolate(cellid, u, v, w);
    }

    value_type evaluate(double x, double y, double z, bool world=true) const 
    {
        return this->evaluate(vec3(x,y,z), world);
    }

    const coord3& shape() const {
        return m_sizes;
    }

    vec3 vertex(const coord3& c) const 
    {
        if (!self_type::check_vertex_coordinates(c, m_sizes))
            throw std::runtime_error("Invalid vertex coordinates in BlockOfValues::vertex");
        return m_origin + (c.array().cast<double>() * m_spacings.array()).matrix();
    }

    std::pair<vec3, vec3> bounds(const coord3& c) const 
    {
        if (!self_type::check_cell_coordinates(c, m_sizes))
            throw std::runtime_error("Invalid cell coordinates in BlockOfValues::bounds");
        vec3 _min = this->vertex(c).pos;
        vec3 _max = _min + m_spacings;
        return std::make_pair(_min, _max);
    }

    void in_bounds(std::vector<coord3>& voxels, const std::pair<coord3, coord3>& bounds)
    {
        const coord3& _min = bounds.first;
        const coord3 &_max = bounds.second;
        vec3 pmin = _min.cast<double>() - m_origin;
        pmin = (pmin.array() / m_spacings.array()).matrix();
        coord3 minid = pmin.cast<uint>();
        vec3 pmax = _max.cast<double>() - m_origin;
        pmax = (pmax.array() / m_spacings.array()).matrix();
        coord3 maxid = pmax.cast<uint>();
        maxid -= coord3(1,1,1);
        for (uint i=0; i<3; ++i)
        {
            minid[i] = std::min<uint>(std::max<uint>(0, minid[i]), m_sizes[i]-2);
            maxid[i] = std::min<uint>(std::max<uint>(0, maxid[i]), m_sizes[i]-2);
        }
        voxels.clear();
        for (uint k=minid[2]; k<=maxid[2]; ++k)
        {
            for (uint j=minid[1]; j<=maxid[1]; ++j)
            {
                for (uint i=minid[0]; i<=maxid[0]; ++i)
                {
                    voxels.push_back(coord3(i,j,k));
                }
            }
        }
    }

    const coord3& sizes() const 
    {
        return m_sizes;
    }

    const vec3& spacings() const
    {
        return m_spacings;
    }

    const vec3& origin() const
    {
        return m_origin;
    }

    coord3 m_sizes;
    vec3 m_spacings;
    vec3 m_origin;
    std::vector<value_type> m_data;
};
typedef BlockOfValues<double> BlockOfScalars;
typedef BlockOfValues<double, vec3> BlockOfVectors;
typedef BlockOfValues<double, mat3> BlockOfMatrices;

struct EdgeParam {
    uint resolution;
    double min_distance;
    double min_value;
    double min_strength;
    double epsilon;
    double min_criterion;
    double min_determinant;
};

template<typename Array>
void import_nrrd(Array& out, const std::string& filename)
{
    Nrrd* nin = nrrdNew();

    if (nrrdLoad(nin, filename.c_str(), NULL))
    {
        char* err = biffGetDone(NRRD);
        std::cerr << "Peikert ridge method: " << err << std::endl;
        exit(-1);
    }

    out = Array(nin);
}

template<typename T>
T sign(const T& value) {
    if (value >= 0) return T(1);
    else return T(-1);
}

uint distance(const vec3& c0, const vec3& c1) {
    return (c1-c0).lpNorm<Eigen::Infinity>();
}

struct EdgeID: public std::pair< coord3, coord3 >
{
    typedef std::pair< coord3, coord3 > base_type;

    EdgeID(const coord3& c0, const coord3& c1)
        : base_type(c0, c1) {
        Less less;
        if (less(c1, c0)) {
            coord3 tmp = base_type::first;
            base_type::first = base_type::second;
            base_type::second = tmp;
        }
    }

    bool operator<(const EdgeID& other) const {
        Less less;
        if (less(base_type::first, other.first)) return true;
        else if (less(other.first, base_type::first)) return false;
        else return less(base_type::second, other.second);
    }
};

std::ostream& operator<<(std::ostream& os, const coord3& id) {
    os << "[" << id[0] << "," << id[1] << "," << id[2] << "]";
    return os;
}

std::ostream& operator<<(std::ostream& os, const vec3& id) {
    os << "[" << id[0] << "," << id[1] << "," << id[2] << "]";
    return os;
}

std::ostream& operator<<(std::ostream& os, const mat3& m) {
    os << "[" << "[" << m(0,0) << "," << m(0,1) << "," << m(0,2) << "],"
       <<        "[" << m(1,0) << "," << m(1,1) << "," << m(1,2) << "]," 
       <<        "[" << m(2,0) << "," << m(2,1) << "," << m(2,2) << "] ]";
    return os;
}

template<typename T, size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T, N>& a)
{
    os << "[";
    std::for_each(a.begin(), a.end(), [&](T v) {
        os << v << ", ";
    });
    os << "]";
    return os;
}

std::ostream &
operator<<(std::ostream &os, const EdgeID &e)
{
    os << "[" << e.first << " - " << e.second << "]";
    return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {
    os << "[";
    if (v.size() > 0) 
    {
        for (uint i=0; i<v.size()-1; ++i) os << v[i] << ", ";
        os << v.back();
    }
    os << "]";
    return os;
}

std::ostream& operator<<(std::ostream& os, const Voxel::VertexInfo& vinfo) {
    os << "( coord: " << vinfo.coord << ", pos: " << vinfo.pos << ", value: " << vinfo.value
    << ", gradient: " << vinfo.gradient << ", hessian: " << vinfo.hessian << " )";
    return os;
}

std::ostream &operator<<(std::ostream &os, const Voxel &v)
{
    os << "min-max: " << v.m_min << ", " << v.m_max << '\n';
    os << "coord: " << v.coord << '\n';
    os << "values: " << v.values << '\n';
    os << "gradients: " << v.gradients << '\n';
    os << "hessians: " << v.hessians << '\n';
    return os;
}

template<typename T>
T invlinear(const T& f0, const T& f1, double umin=0, double umax=1) {
    // f = f0 + (u - umin) / (umax - umin) * (f1 - f0)
    // f = 0 <=> -f0 / (f1 - f0) = (u - umin) / (umax - umin)
    // f = 0 <=> u = -f0 / (f1 - f0) * (umax - umin) + umin    
    return umin - f0/(f1-f0)*(umax-umin);
}

template<typename T>
T linear(double u, const T& v0, const T& v1) {
    return (1.-u)*v0 + u*v1;
}

std::pair<double, vec3> evmin(const mat3& H) {
    eigensolver_type solver;
    // std::cout << "About to compute eigenvalues for " << H << '\n';
    mat3 M = H;
    solver.compute(H);
    // std::cout << "done.\n";
    if (H.maxCoeff() > 1000.) {
        std::cout << "matrix H is " << H << '\n';
        std::cout << "copy of H is " << M << '\n';
        throw std::runtime_error("Invalid hessian value: " + std::to_string(H.maxCoeff()));
    }
    return std::make_pair(solver.eigenvalues()[0], solver.eigenvectors().col(0));
}

std::pair<vec3, mat3> evall(const mat3& H) {
    eigensolver_type solver;
    solver.compute(H);
    return std::make_pair(solver.eigenvalues(), solver.eigenvectors());
}

double determinant(const vec3& g, const mat3& H, bool normalize=false) {
    mat3 A;
    A.col(0) = g;
    A.col(1) = H * g;
    A.col(2) = H * A.col(1);

    if (normalize) {
        A.col(0) /= g.norm();
        A.col(1) /= A.col(1).norm();
        A.col(2) /= A.col(2).norm();
    }
    return A.determinant();
};

template<typename T>
class LinearFunction {
public:
    typedef T value_type;

    LinearFunction() : m_v0(), m_v1() {}

    LinearFunction(const value_type& val0, const value_type& val1) :
        m_v0(val0), m_v1(val1) {}

    value_type operator()(double u) const {
        return linear(u, m_v0, m_v1);
    }

private:
    value_type m_v0, m_v1;
};

typedef LinearFunction<double> scalar_function;
typedef LinearFunction<vec3> vector_function;
typedef LinearFunction<mat3> matrix_function;

class C0Criterion {
public:
    C0Criterion(const vector_function& gfunc, const matrix_function& hfunc) {
        m_gfunc = gfunc;
        m_hfunc = hfunc;
    }

    double operator()(double u) const {
        auto g = m_gfunc(u);
        auto h = m_hfunc(u);
        return determinant(g, h);
    }
private:
    vector_function m_gfunc;
    matrix_function m_hfunc;
};

template<typename Func>
double find_zero_crossing(const Func& func, double umin = 0, double umax = 1, double eps=1.0e-12, uint maxn=100) {
    // pruint('find zero crossing')
    double fmin = func(umin);
    double fmax = func(umax);
    if (fmin * fmax >= 0) return -1;
    // det(0) * det(1) < 0

    double f = 1;  // default value
    double u;
    for (uint n=0; ((umax - umin) > 1.0e-9 or std::fabs(f) > eps) and n < maxn; ++n) {
        u = 0.5 * (umin + umax);
        f = func(u);
        if (fmin*f < 0) {
            umax = u;
            fmax = f;
        } 
        else {
            umin = u; 
            fmin = f;
        } 
    }
    return u;
}

std::pair<vec3, double> project(const vec3& g, const mat3& h) {
    auto r = evall(h);
    vec3 evals = r.first;
    mat3 evecs = r.second;
    vec3 coords = (evecs.transpose()*g).array().abs().matrix();
    return std::make_pair(coords, evals[0]);
}

bool check_solution(double u, const vector_function& gfunc, const matrix_function& hfunc,
                    bool verbose=false) {
    auto r = evall(hfunc(u));
    vec3 evals = r.first;
    mat3 evecs = r.second;
    vec3 coords = (evecs.transpose()*gfunc(u)).array().abs().matrix();
    if (verbose) {
        std::cout << "eigenvalues: " << evals << '\n'
        << "eigenvectors: " << evecs << '\n'
        << "coordinates: " << coords << '\n';
    }

    Eigen::Index which;
    double minval = coords.minCoeff(&which);
    return (which == 0) && minval < 1.0e-6*coords.mean();
}

uint case_number(const std::array<bool, 12>& edges) {
    std::cout << "edges=" << edges << '\n';
    std::array<uint, 8> states({{0, 0, 0, 0, 0, 0, 0, 0}});
    // 0: not set
    // -1 or 1: positive or negative value
    states[0] = -1; // arbitrary initialization
    // The following order ensures that vertices are visited in order
    uint edges_order[] = {0, 1, 2, 8, 9, 10, 11, 3, 4, 5, 6, 7};
    for (uint e = 0; e < 12; ++e)
    {
        uint edgeid = edges_order[e];
        auto v0 = canonical_edge_indices[edgeid][0];
        auto v1 = canonical_edge_indices[edgeid][1];
        if (v0 > v1)
        {
            std::swap(v0, v1);
        }
        if (e < 7)
        {
            if (edges[edgeid])
                states[v1] = -states[v0];
            else
                states[v1] = states[v0];
        }
        else
        {
            if ((edges[edgeid] && edges[v1] * edges[v0] > 0) ||
                (!edges[edgeid] && edges[v1] * edges[v0] < 0))
                return -1; // failed
        }
        std::cout << "e=" << e << ", edgeid=" << edgeid << ", states=" << states << '\n';
    }

    uint cn = 0;
    for (uint i = 0; i < 8; ++i)
    {
        if (states[i] > 0)
        {
            cn += 1 << i;
        }
    }
    return cn;
}

typedef std::array<vec3, 3> triangle_type;
uint triangulate(std::vector<triangle_type>& out, 
                 std::map<uint, std::vector<vec3>> &edges, 
                 std::ostream& os)
{
    os << "triangles: edges contains " << edges.size() << " edges with ridge pouints\n";
    out.clear();

    std::map<uint, uint> edge_to_nbsols;
    uint nbsols = 0;
    for (auto iter=edges.begin(); iter!=edges.end(); ++iter) 
    {
        edge_to_nbsols[iter->first] = iter->second.size();
        nbsols += iter->second.size();
    }

    os << "There are " << nbsols << " ridge pouints over " << edges.size() << " in total\n";

    // if we only have 3 or less pouints, things are easy
    if (edges.size() == 3 && nbsols == 3) 
    {
        triangle_type T;
        uint i=0;
        for (auto iter=edges.begin(); iter!=edges.end(); ++iter, ++i) 
        {
            T[i] = iter->second[0];
        }
        out.push_back(T);
        os << "3 pouints on 3 edges: success!\n";
        return one_triangle;
    }
    else if (edges.size() < 3)
    {
        os << "We have only 2 (or less) edges in input of triangulation.\n"
           << "Giving up (Case N<3)\n";
        return not_enough_edges;
    }
    // If we have several pouints on one edge and two edges, 
    // we could triangulate put that implies finding a ridge 
    // that ends in this voxel.
    /*
        ------X---- 
       |    / |    |
       |   /  |    |
       |  /   |    |
        --X---X----
    */

    if (nbsols == edges.size()) 
    {
        // Calculate edge case number
        uint edge_case = 0;
        for (auto iter=edges.begin(); iter!=edges.end(); ++iter) 
        {
            edge_case += 1 << iter->first;
        }
        os << "edge_case = " << edge_case << '\n';
        uint triangle_case = edge_code_to_case_id[edge_case];
        os << "triangle_case = " << triangle_case << '\n';

        if (triangle_case == -1) // invalid
        {
            os << "the edges do not match a valid MC case...\n Giving up. (Case NoMC)\n";
            return invalid_mc_case;
        }

        auto indices = triTable[triangle_case];
        for (uint i=0; i<15 && indices[i]!=-1; i+=3) 
        {
            out.push_back(triangle_type({{edges[indices[i]][0], edges[indices[i+1]][0], edges[indices[i+2]][0]}}));
            const triangle_type& t = out.back();
            os << "added triangle: " << t << '\n';
        }
        os << "A valid MC case was found and " << out.size() << " triangles "
           << "were created.\n";
        return valid_mc_case;
    }
    else
    {
        // 3 or more edges, some of which have several pouints
        // for now, do nothing
        return exotic_case;
    }
}

void fit_spline(tk::spline& spline, const std::vector<double>& u, C0Criterion& f) {
    std::vector<double> values;
    std::for_each(u.begin(), u.end(), [&](double x){ values.push_back(f(x)); });
    spline.set_points(u, values);
}

std::vector<double> bisection_spline_local_extremum(tk::spline &, double, double, bool);

std::vector<double> newton_spline_local_extremum(tk::spline &spline, double u0, double u1, bool verbose)
{
    // Newton:
    // f(x+dx) = 0 = f(x) + f'(x)dx <=> dx = -f(x)/f'(x)
    double f0 = spline(u0);
    double f1 = spline(u1);
    double u = -f0/(f1-f0); // initial guess (linear solution)
    double f = spline.deriv(1, u);
    uint iter = 0;
    std::vector<double> all_us;
    if (verbose)
    {
        std::cout << "Looking for local extremum\n";
    }
    while (std::abs(f) > 1.0e-6 && iter < 10)
    {
        double d2f = spline.deriv(2, u);
        all_us.push_back(u);
        if (d2f == 0)
        {
            if (verbose) std::cout << "vanishing 2nd derivative: resorting to bisection\n";
            return bisection_spline_local_extremum(spline, u0, u1, verbose);
        }
        double dx = -f / d2f;
        double uu = u + dx;
        if (uu > u1) u = u1;
        else if (uu < u0) u = u0;
        else u = uu;
        if (verbose)
        {
            std::cout << "u=" << u << ", df/dt=" << f << ", d2f/dt2=" << d2f << ", dx=" << dx << '\n';
        }
        f = spline.deriv(1, u);
        if (verbose)
        {
            std::cout << "df/dt=" << f << '\n';
        }
        iter += 1;
    }
    return all_us;
}

std::vector<double> bisection_spline_local_extremum(tk::spline& spline, double u0, double u1, bool verbose) 
{
    double f0 = spline.deriv(1, u0);
    double f1 = spline.deriv(1, u1);
    double u, t;
    std::vector<double> all_us;
    for (uint i=0; i<10; ++i) 
    {
        t = -f0/(f1-f0);
        u = (1-t)*u0 + t*u1;
        all_us.push_back(u);
        double f = spline.deriv(1, u);
        if (verbose)
        {
            std::cout << "bisection search: iteration " << i << ", df/dt=" << f << ", u0=" << u0 << ", u1=" << u1 << '\n';
        }
        if (f*f0 > 0)
        {
            u0 = u;
            f0 = f;
        }
        else
        {
            u1 = u;
            f1 = f;
        }
    }
    t = -f0/(f1-f0);
    u = (1 - t) * u0 + t * u1;
    all_us.push_back(u);
    double f = spline.deriv(1, u);
    if (verbose)
    {
        std::cout << "final derivative: " << f << '\n';
    }
    return all_us;
}

std::pair<uint, std::vector<double>>
analyze_edge(const std::pair<Voxel::VertexInfo, Voxel::VertexInfo>& edge_info,
             const EdgeParam &params,
             bool verbose = false)
{   
    vector_function gfunc(edge_info.first.gradient, edge_info.second.gradient);
    matrix_function hfunc(edge_info.first.hessian, edge_info.second.hessian);
    C0Criterion cfunc(gfunc, hfunc);

    // 0 --- 1/3 --- 2/3 --- 3/3: N=4, du=1/3 
    
    double du = 1./static_cast<double>(params.resolution-1);
    std::map<double, double> values;
    std::vector<double> xs;
    
    for (uint i=0; i<params.resolution; ++i) {
        xs.push_back(std::min(i*du, 1.));
    }
    tk::spline init_spline;
    fit_spline(init_spline, xs, cfunc);
    std::vector<double> derivs;
    for (uint i=0; i<xs.size(); ++i) {
        derivs.push_back(init_spline.deriv(1, xs[i]));
        values[xs[i]] = init_spline(xs[i]);
        if (std::isnan(derivs.back()) || std::isnan(values[xs[i]]))
        {
            std::cout << "ERROR in analyze_edge\n";
            std::cout << "edge_info was:\n";
            std::cout << "0: " << edge_info.first << '\n';
            std::cout << "1: " << edge_info.second << '\n';
        }
    }

    // check if derivative has constant sign in which case we are good
    double asign = sign(derivs[0]);
    std::vector<std::pair<double, double>> where;
    if (verbose)
    {
        std::cout << "sampling spline derivative along edge\n";
        std::cout << "sample #0: "  << derivs[0] << '\n';
    }
    // find root of derivative iff:
    // 1. downward then upward + both values positive: local min may be negative
    // 2. upward then downward + both values negative: local max may be positive
    for (uint i=1; i<derivs.size(); ++i) {
        if (verbose)
        {
            std::cout << "sample #" << i << ": " << derivs[i] << '\n';
            std::cout << "value #" << i << ": " << values[xs[i]] << '\n';
        }
        double newsign = sign(derivs[i]);
        if (asign * newsign < 0) {
            if (verbose)
            {
                std::cout << "sign change\n";
            }
            if ((asign > 0 && values[i-1] < 0 && values[i] < 0) || // local maximum may be positive
                (asign < 0 && values[i-1] > 0 && values[i] > 0)) // local minimum may be negative
                where.push_back(std::make_pair(xs[i-1], xs[i]));
            asign = newsign;
        }
    }
    if (verbose)
        std::cout << where.size() << " potential hidden zero crossings detected\n";

    for (uint i=0; i<where.size(); ++i)
    {
        double u0 = where[i].first;
        double u1 = where[i].second;
        // double u = bisection_spline_local_extremum(init_spline, u0, u1, verbose);
        std::vector<double> new_us = newton_spline_local_extremum(init_spline, u0, u1, verbose);
        // found zero crossing of derivative
        std::for_each(new_us.begin(), new_us.end(), [&](double u)
        {
            values[u] = cfunc(u);
        });
    }

    if (verbose) {
        std::cout << "After spline-based refinement, samples are:\n";
        for (auto iter=values.begin(); iter!=values.end(); ++iter) {
            std::cout << std::setprecision(32) << iter->first << ": " << iter->second << '\n';
        }
    }
    std::vector<double> ridge_points;

    for (auto iter=values.begin(); iter!=values.end(); ++iter)
    {
        auto next = iter;
        ++next;
        if (next == values.end()) break;
        double u0 = iter->first;
        double f0 = iter->second;
        double u1 = next->first;
        double f1 = next->second;
        if (f0*f1 < 0)
        {
            if (verbose) {
                std::cout << "zero crossing found between " << u0 << " and " << u1 << '\n';
            }
            double u = find_zero_crossing(cfunc, u0, u1);
            if (check_solution(u, gfunc, hfunc, verbose))
            {
                if (verbose)
                    std::cout << "ridge point found\n";
                ridge_points.push_back(u);
            }
            else if (verbose) {
                std::cout << "no ridge point found\n";
            }
        }
    }

    if (ridge_points.size() == 1)
        return std::make_pair(one_ridge_point, ridge_points);
    else if (ridge_points.size() > 1)
        return std::make_pair(several_ridge_points, ridge_points);
    else
        return std::make_pair(no_ridge_point, std::vector<double>());
}

std::pair<double, double> evaluate(const vec3&, const BlockOfScalars&, const BlockOfMatrices&); 

int process_voxel(std::vector<triangle_type> &all_triangles,
                  const Voxel& avoxel,
                  std::map<EdgeID, std::vector<vec3>> &known_edges,
                  const EdgeParam &params,
                  bool verbose)
{
    std::map<uint, std::vector<vec3>> found;
    for (uint i = 0; i < 12; ++i)
    {
        auto einfo = avoxel.edge_info(i);
        EdgeID edgeid(einfo.first.coord, einfo.second.coord);
        auto iter = known_edges.find(edgeid);
        if (iter != known_edges.end())
        {
            if (verbose) std::cout << "skipping known edge\n";
            if (!iter->second.empty())
                found[i] = iter->second;
        }
        else
        {
            auto result = analyze_edge(einfo, params, verbose);
            auto coordinates = result.second;

            known_edges[edgeid] = std::vector<vec3>();
            if (!coordinates.empty())
            {
                for (uint k = 0; k < coordinates.size(); ++k)
                {
                    double u = coordinates[k];
                    found[i].push_back((1. - u) * einfo.first.pos + u * einfo.second.pos);
                }
                known_edges[edgeid] = found[i];
                if (coordinates.size() > 1)
                {
                    return -1;
                }
            }
        }
    }

    if (found.size() >= 3)
    {
        std::vector<triangle_type> tris;
        std::ostringstream log;
        uint tri_case;
        if (verbose)
            tri_case = triangulate(tris, found, std::cout);
        else
            tri_case = triangulate(tris, found, log);

        if (tris.size() > 0)
        {
            std::for_each(tris.begin(), tris.end(), [&](auto T)
                          { all_triangles.push_back(T); });
            return tris.size();
        }
        else
        {
            if (verbose)
                std::cout << "Triangulation failed\n";
            return -1;
        }
    }
    else if (found.size() > 0)
        return -1;
    else
        return 0;
}

std::pair<double, double> evaluate(const vec3& pouint,
                                   const BlockOfScalars& values, 
                                   const BlockOfMatrices& hessian) 
{
    vec3 low;
    uint dim = -1;
    for (uint i=0; i<3; ++i) {
        low[i] = std::trunc(pouint[i]);
        if (pouint[i] - low[i] > 1.0e-6) { // we are working in index space
            dim = i;
        }
    }
    if (dim == -1) {
        std::ostringstream os;
        os << "Invalid edge coordinate: " << pouint;
        throw std::runtime_error(os.str());
    }
    vec3 high = low;
    high[dim] += 1;
    mat3 H0 = hessian(low[0], low[1], low[2]);
    double v0 = values(low[0], low[1], low[2]);
    mat3 H1 = hessian(high[0], high[1], high[2]);
    double v1 = values(high[0], high[1], high[2]);
    scalar_function v(v0, v1);
    matrix_function h(H0, H1);
    double u = (pouint[dim]-low[dim])/(high[dim]-low[dim]);
    return std::make_pair(v(u), evmin(h(u)).first);
}

std::pair<uint, std::vector<double>> process_edge(const std::pair<Voxel::VertexInfo, Voxel::VertexInfo> &edge_info,
                                                 const EdgeParam &params,
                                                 bool verbose = false)
{
    if (verbose) {
        std::cout << "\n\nprocessing edge " << edge_info.first.coord << " - " << edge_info.second.coord << '\n';
    }
    std::vector<double> solutions; // initially empty
    
    scalar_function sfunc(edge_info.first.value, edge_info.second.value);
    vector_function gfunc(edge_info.first.gradient, edge_info.second.gradient);
    matrix_function hfunc(edge_info.first.hessian, edge_info.second.hessian);
    double lmin0 = evmin(hfunc(0)).first;
    double lmin1 = evmin(hfunc(1)).first;
    C0Criterion cfunc(gfunc, hfunc);

    // check if we are dealing with a degenerate case or one that
    // does not meet prescribed filtering criteria
    if (std::max(std::fabs(cfunc(0)), std::fabs(cfunc(1))) < params.min_criterion) 
    {
        return std::make_pair(criterion_underflow, solutions);
    }
    else if (std::max(lmin0, lmin1) > -std::fabs(params.min_strength)) 
    {
        return std::make_pair(weak_ridge, solutions);
    }
    else if (std::max(sfunc(0), sfunc(1)) < params.min_value) 
    {
        return std::make_pair(low_ridge, solutions);
    }
    
    // initial uniform sampling
    std::vector<double> dets;
    double step = 1./double(params.resolution-1);
    for (double u=0; u<1+step; u+=step) 
    {
        dets.push_back(cfunc(u));
        if (verbose) 
        {
            std::cout << "det[" << u << "] = " << dets.back() << '\n';
        }
    }
    
    // adaptive zero-crossing search
    for (uint i=0; i<dets.size()-1; ++i) 
    {
        double u0 = i*step;
        double u1 = u0 + step;
        const double& det0 = dets[i];
        const double& det1 = dets[i+1];
        if (det0 * det1 < 0) 
        {
            if (verbose) 
            {
                std::cout << "zero crossing found between " << u0 << " and " << u1 << '\n';
            }
            double u = find_zero_crossing(cfunc, u0, u1);
            if (verbose) 
            {
                std::cout << "zero crossing found at u=" << u << '\n';
            }
            if (u>=0 && check_solution(u, gfunc, hfunc, verbose)) 
            {
                solutions.push_back(u);
                if (verbose)
                    std::cout << "zero crossing found to be a ridge pouint\n";
            }
            else if (verbose) 
            {
                std::cout << "zero crossing is not a valid ridge pouint\n";
            }
        }
    }

    if (solutions.size() == 1) 
    {
        return std::make_pair(one_ridge_point, solutions);
    }
    else if (solutions.size() == 0) 
    {
        return std::make_pair(no_ridge_point, solutions); // code for nothing found
    }
    else 
    {
        return std::make_pair(several_ridge_points, solutions);
    }
}

template<typename T>
struct parser_traits;

template<>
struct parser_traits<int> 
{
    static std::regex get()
    {
        return std::regex("([-0-9]+)");
    }
    static int cast(const std::string& s) 
    {
        return std::stoi(s);
    }
};

template<>
struct parser_traits<double> 
{
    static std::regex get()
    {
        return std::regex("([+-]? *[0-9]+(\\.[0-9]+)?)");
    }
    static uint cast(const std::string &s)
    {
        return std::stod(s);
    }
};

template<typename T=uint>
void parse_values(std::vector<T>& out, const std::string& str, size_t n) 
{
    std::regex myregex = parser_traits<T>::get();
    auto begin = std::sregex_iterator(str.begin(), str.end(), myregex);
    auto end = std::sregex_iterator();
    std::cout << "Found " << std::distance(begin, end) << " values\n";
    if (std::distance(begin, end) == n)
    {
        uint i = 0;
        for (std::sregex_iterator iter = begin; iter != end; ++iter, ++i)
        {
            std::smatch match = *iter;
            std::cout << "value=" << match.str() << std::endl;
            out.push_back(parser_traits<T>::cast(match.str()));
        }
    }
    else 
    {
        throw std::runtime_error("invalid input");
    }
}

void save_sampled_voxel(const std::string& filename, coord3& voxel_id, 
                        const BlockOfVectors& gradient, 
                        const BlockOfMatrices& hessian,
                        const size_t resolution=101)
{
    std::vector<mat3> H(8);
    std::vector<vec3> g(8);
    for (uint i = 0; i < 8; ++i)
    {
        auto shift = vertices[i];
        coord3 pid = voxel_id + coord3(shift[0], shift[1], shift[2]);
        H[i] = hessian(pid[0], pid[1], pid[2]);
        g[i] = gradient(pid[0], pid[1], pid[2]);
    }
    std::vector<double> det_values(2 * resolution * resolution * resolution);
    double dh = 1./static_cast<double>(resolution-1);
    for (uint k = 0; k < resolution; ++k)
    {
        double z = k * dh;
        double Z = 1. - z;
        for (uint j = 0; j < resolution; ++j)
        {
            double y = j * dh;
            double Y = 1. - y;
            for (uint i = 0; i < resolution; ++i)
            {
                double x = i * dh;
                double X = 1. - x;
                mat3 theH = X * Y * Z * H[0] + x * Y * Z * H[1] + x * y * Z * H[2] + X * y * Z * H[3] +
                            X * Y * z * H[4] + x * Y * z * H[5] + x * y * z * H[6] + X * y * z * H[7];
                vec3 theg = X * Y * Z * g[0] + x * Y * Z * g[1] + x * y * Z * g[2] + X * y * Z * g[3] +
                            X * Y * z * g[4] + x * Y * z * g[5] + x * y * z * g[6] + X * y * z * g[7];
                det_values[2 * (i + resolution * (j + resolution * k))] = determinant(theg, theH);
                det_values[2 * (i + resolution * (j + resolution * k)) + 1] = (project(theg, theH).first)[0];
            }
        }
    }
    size_t sizes[4] = {2, resolution, resolution, resolution};
    std::ostringstream os;
    os << filename << "_voxel_" << voxel_id[0] << "_" << voxel_id[1] << "_" << voxel_id[2] << ".nrrd";
    spurt::nrrd_utils::writeNrrd((void *)&det_values[0], os.str(), nrrdTypeDouble, 4, sizes);
}

int check_voxel(const Voxel &voxel, double minval, double minstr)
{
    // check if current voxel satisfies threshold requirements
    std::vector<double> s_values(8);
    s_values[0] = evmin(voxel.hessian(0)).first;
    s_values[1] = evmin(voxel.hessian(1)).first;
    s_values[2] = evmin(voxel.hessian(2)).first;
    s_values[3] = evmin(voxel.hessian(3)).first;
    s_values[4] = evmin(voxel.hessian(4)).first;
    s_values[5] = evmin(voxel.hessian(5)).first;
    s_values[6] = evmin(voxel.hessian(6)).first;
    s_values[7] = evmin(voxel.hessian(7)).first;
    if (*std::max_element(&voxel.values[0], &voxel.values[8]) < minval) return -1;
    if (*std::min_element(&s_values[0], &s_values[8]) > minstr) return -2;
    else return 1;
}

void make_voxel(Voxel& avoxel, const coord3& index, uint depth, const BlockOfScalars& values,
                const BlockOfVectors& gradient, const BlockOfMatrices& hessian)
{
    uint scaling = 1 << depth;
    coord3 actual_index, shift;
    for (uint d=0; d<3; ++d) 
    {
        std::ldiv_t frac = std::div(static_cast<long>(index[d]), static_cast<long>(scaling));
        actual_index[d] = frac.quot;
        shift[d] = frac.rem; 
    }

    vec3 base = values.vertex(actual_index);
    vec3 spc = values.spacings()/double(scaling);
    vec3 min_ = base + (spc.array() * shift.array().cast<double>()).matrix();
    vec3 max_ = min_ + spc;
    avoxel.set_bounds(min_, max_);
    avoxel.coord = index;
    for (uint i=0; i<8; ++i) 
    {
        vec3 step(vertices[i][0], vertices[i][1], vertices[i][2]);
        vec3 p = min_ + (step.array() * spc.array()).matrix();
        avoxel.value(i) = values.evaluate(p);
        avoxel.gradient(i) = gradient.evaluate(p);
        avoxel.hessian(i) = hessian.evaluate(p);
    }
}

void export_triangles(const std::vector<triangle_type> &triangles,  
                      const std::vector<std::array<double, 2>>& attributes,
                      const std::string &filename)
{
    std::map<vec3, size_t, PosLexico> pos_to_id;
    std::map<size_t, size_t> new_to_old_id;
    std::vector<std::array<size_t, 3>> tris;
    size_t id = 0;
    for (size_t i = 0; i < triangles.size(); ++i)
    {
        std::array<size_t, 3> atri;
        for (int j = 0; j < 3; ++j)
        {
            const vec3 &p = triangles[i][j];
            auto iter = pos_to_id.find(p);
            if (iter != pos_to_id.end())
            {
                atri[j] = iter->second;
            }
            else
            {
                atri[j] = id;
                new_to_old_id[id] = 3*i+j;
                pos_to_id[p] = id++;
            }
        }
        tris.push_back(atri);
    }
    vtkDoubleArray *coords = vtkDoubleArray::New();
    coords->SetNumberOfComponents(3);
    coords->SetNumberOfTuples(pos_to_id.size());
    vtkDoubleArray *vals = vtkDoubleArray::New();
    vals->SetName("Values");
    vals->SetNumberOfComponents(1);
    vals->SetNumberOfTuples(pos_to_id.size());
    vtkDoubleArray *strs = vtkDoubleArray::New();
    strs->SetNumberOfComponents(1);
    strs->SetNumberOfTuples(pos_to_id.size());
    strs->SetName("Strength");
    for (auto iter = pos_to_id.begin(); iter != pos_to_id.end(); ++iter)
    {
        coords->SetTuple3(iter->second, iter->first[0], iter->first[1], iter->first[2]);
        vals->SetTuple1(iter->second, attributes[new_to_old_id[iter->second]][0]);
        strs->SetTuple1(iter->second, attributes[new_to_old_id[iter->second]][1]);
    }
    vtkPoints *points = vtkPoints::New();
    points->SetData(coords);
    vtkCellArray *cells = vtkCellArray::New();
    for (size_t i = 0; i < triangles.size(); ++i)
    {
        cells->InsertNextCell(3);
        cells->InsertCellPoint(tris[i][0]);
        cells->InsertCellPoint(tris[i][1]);
        cells->InsertCellPoint(tris[i][2]);
    }
    vtkPolyData *poly = vtkPolyData::New();
    poly->SetPoints(points);
    poly->SetPolys(cells);
    poly->GetPointData()->AddArray(vals);
    poly->GetPointData()->AddArray(strs);
    vtkXMLPolyDataWriter *writer = vtkXMLPolyDataWriter::New();
    writer->SetFileName(filename.c_str());
    writer->SetInputData(poly);
    writer->Write();
}

int main(int argc, const char *argv[])
{
    std::string data_name, gradient_name, hessian_name, output_name;
    double minval, minstr, eps, mind;
    uint res, niter;
    bool verbose;
    coord3 voxel_id;
    std::pair<coord3, coord3> bounds;
    std::string voxel_str = "(-1, -1, -1)";
    std::string bounds_str = "(0, -1; 0, -1; 0, -1)";
    int maxdepth = 3;
    

    namespace cl = spurt::command_line;
    cl::option_traits
        required_group(true, false, "Required Options"),
        positional_group(true, true, "Positional Group"),
        optional_group(false, false, "Optional Group");

    cl::option_parser parser(argv[0],
                             "Extract ridge surfaces from scalar volume using\nPeikert and Sadlo's level set method");
    try 
    {
        parser.use_short_symbols(false);
        parser.use_brackets(true);

        parser.add_value("value", data_name, "Scalar raster filename", required_group);
        parser.add_value("gradient", gradient_name, "Gradient raster filename", required_group);
        parser.add_value("hessian", hessian_name, "Hessian raster filename", required_group);
        parser.add_value("output", output_name, "Output filename", required_group);
        parser.add_value("minval", minval, 0., "Min scalar value", optional_group);
        parser.add_value("minstr", minstr, 0., "Min ridge strength", optional_group);
        parser.add_value("eps", eps, 1.0e-9, "Numerical precision", optional_group);
        parser.add_value("mindist", mind, 0.02, "Min sampling distance", optional_group);
        parser.add_value("verbose", verbose, false, "Verbose output", optional_group);
        parser.add_value("res", res, 10, "Initial (coarse) sampling resolution to find ridge pouints", optional_group);
        parser.add_value("niter", niter, 100, "Max number of iterations of the zero crossing algorithm", optional_group);
        parser.add_value("voxel", voxel_str, voxel_str, "Coordinates of single voxel to process");
        parser.add_value("bounds", bounds_str, bounds_str, "Bounds of domain to consider");
        parser.add_value("maxdepth", maxdepth, maxdepth, "Maximum refinement depth");
        parser.parse(argc, argv);
    }
    catch (std::runtime_error &e)
    {
        std::cerr << "ERROR(1): " << argv[0] << " threw exception:\n"
                  << e.what() << "\n"
                  << "Command line options entered so far:\n"
                  << parser.print_self(false, true, false) << "\n\n\n";
        exit(1);
    }
    catch (std::exception &e)
    {
        std::cerr << "ERROR(2): " << argv[0] << " threw exception:\n"
                  << e.what() << "\n"
                  << "Command line options enteredso far:\n"
                  << parser.print_self(false, true, false) << "\n\n\n";
        exit(1);
    }

    bool valid_voxel_id = false;
    bool valid_bounds = false;
    {
        std::vector<int> iv;
        parse_values<int>(iv, voxel_str, 3);
        std::cout << iv << '\n';
        if (iv[0] != -1)
        {
            voxel_id = { iv[0], iv[1], iv[2] };
            valid_voxel_id = true;
        }

        std::vector<int> dv;
        parse_values<int>(dv, bounds_str, 6);
        std::cout << dv << '\n';
        if (dv[0] != -1)
        {
            bounds.first = { dv[0], dv[2], dv[4] };
            bounds.second = { dv[1], dv[3], dv[5] };
            valid_bounds = true;
        }
    }

    BlockOfScalars values;
    BlockOfVectors gradients;
    BlockOfMatrices hessians;
    import_nrrd(values, data_name);
    import_nrrd(gradients, gradient_name);
    import_nrrd(hessians, hessian_name);

    EdgeParam params;
    params.resolution = res;
    params.epsilon = eps;
    params.min_distance = mind;
    params.min_value = minval;
    params.min_strength = minstr;
    params.min_determinant = 1.0e-9;
    params.min_criterion = 1.0e-9;

    
    auto shape = values.shape();
    std::vector< coord3 > voxel_ids;

    
    if (valid_voxel_id)
    {
        valid_voxel_id = true;
        voxel_ids.clear();
        voxel_ids.push_back(voxel_id.cast<uint>());
        verbose = true;
    }
    else if (valid_bounds)
    {
        voxel_ids.clear();
        const coord3& l = bounds.first;
        const coord3& h = bounds.second;
        values.in_bounds(voxel_ids, bounds);
    }
    else 
    {
        uint _n = 0;
        voxel_ids.resize((shape[0]-1)*(shape[1]-1)*(shape[2]-1));
        for (uint k = 0; k < shape[2] - 1; ++k)
        {
            for (uint j = 0; j < shape[1] - 1; ++j)
            {
                for (uint i = 0; i < shape[0] - 1; ++i, ++_n)
                {
                    voxel_ids[_n] = coord3(i, j, k);
                }
            }
        }
    }
    std::cout << "There are " << voxel_ids.size() << " voxels in input for a total of " << 12*voxel_ids.size() << " (redundant) edges\n";

    uint nskipped = 0;
    uint nfailed_to_triangulate = 0;
    uint nnot_enough_points = 0;
    uint nsucceeded = 0;
    uint nprocessed = 0;
    uint nexcluded = 0;
    uint nnone = 0;
    uint neven = 0;
    uint nweak = 0;
    uint nlow = 0;
    uint nunderflow = 0;
    uint nfiltered = 0;
    std::vector<triangle_type> all_triangles;
    std::vector<vec4> rejected;

    if (valid_voxel_id)
        save_sampled_voxel(output_name, voxel_id, gradients, hessians);
    
    spurt::ProgressDisplay progress;
    std::vector<coord3> failed_voxels;
    std::vector<uint> voxel_to_edge;
    std::map<coord3, std::vector<uint>, Less> voxel_counter;
    int skipped_voxels=0;
    int nedges = 0;
    int nfound = 0;

    srand48(130819751900);
    for (uint depth=0; depth<maxdepth; ++depth)
    {
        std::cout << "\nProcessing depth=" << depth << '\n';
        // we reset the edge information at each new depth since we have not encountered
        // those half edges yet.
        std::map<EdgeID, std::vector<vec3>> all_processed_edges;
        progress.begin(voxel_ids.size(), "Extract ridges", 1000000, "tris: 0, failed: 0, skipped: 0, edges: 0, found: 0");
        for (uint n=0; n<voxel_ids.size(); ++n) 
        {
            std::string update_str = "tris: " + std::to_string(all_triangles.size()) + 
            ", failed: " + std::to_string(failed_voxels.size()) + ", skipped: " + std::to_string(skipped_voxels)
            + ", edges: " + std::to_string(all_processed_edges.size()) + ", found: " + std::to_string(nfound);
            progress.update(n, update_str);
            coord3 id = voxel_ids[n];
            bool voxel_failed = false;
            // verbose = (id == vec3(6, 14, 13));
            // verbose = (id[0] >= 150 && id[0] <= 160 && id[1] >= 60 && id[1] <= 75 && id[2] >= 60 && id[2] <=65);
            /*if (verbose)
            {
                std::cout << "processing voxel: " << id << '\n';
            }*/
            Voxel avoxel;
            make_voxel(avoxel, id, depth, values, gradients, hessians);

            // check if current voxel satisfies threshold requirements
            int ret = check_voxel(avoxel, minval, minstr);
            if (ret < 0)
            {
                skipped_voxels++;
                // if (verbose) {
                //     if (ret == -1)
                //         std::cout << "voxel was discarded by value\n";
                //     else if (ret == -2)
                //         std::cout << "voxel was discarded by ridge strength\n";
                // }
                continue;
            }
            int ntris = process_voxel(all_triangles, avoxel, all_processed_edges, params, verbose);
            if (ntris < 0) 
            {
                if (verbose) std::cout << "failed voxel\n";
                failed_voxels.push_back(id);
            }
            else if (ntris > 0) 
            {   
                nfound++;
                if (verbose) std::cout << ntris << " triangles found\n";

            }
        }
        std::cout << "There were " << failed_voxels.size() << " failed voxels\n";

        std::vector<vec3> all_edge_pouints;
        for (auto iter=all_processed_edges.begin(); iter!=all_processed_edges.end(); ++iter)
        {
            auto pts = iter->second;
            if (pts.empty())
                continue;
            all_edge_pouints.insert(all_edge_pouints.end(), pts.begin(), pts.end());
        }
        {
            size_t sizes[3] = { 3, all_edge_pouints.size() };
            spurt::nrrd_utils::writeNrrd((void*)&all_edge_pouints[0], output_name + "_all_pouints.nrrd", 
                                        nrrdTypeDouble, 2, sizes);
        }

        progress.end();
        uint nfailed = 0;
        uint nfixed = 0;
        params.resolution = params.resolution * 10;
        std::vector<coord3> still_broken;
        progress.begin(failed_voxels.size(), "Repair ridges", 10000, "tris: 0, done: 0, ok: 0, skip: 0, underflow: 0, weak: 0, low: 0, none: 0, even: 0, failed: 0");
        for (uint n = 0; n < failed_voxels.size(); ++n)
        {
            coord3 id = failed_voxels[n];
            Voxel avoxel;
            make_voxel(avoxel, id, depth, values, gradients, hessians);
            std::map<uint, std::vector<vec3>> found;
            std::string update_str = "fixed: " + std::to_string(nfixed) +
                                    ", failed: " + std::to_string(nfailed);
            progress.update(n, update_str);
            std::ostringstream log;
            for (uint i = 0; i < 12; ++i)
            {
                auto einfo = avoxel.edge_info(i);
                EdgeID edgeid(einfo.first.coord, einfo.second.coord);
                if (verbose)
                    std::cout << "\n\nedge #" << i << " of voxel " << id << " is being reprocessed" << '\n';
                auto result = process_edge(einfo, params, verbose);
                auto coordinates = result.second;
                if (!coordinates.empty())
                {
                    found[i] = std::vector<vec3>();
                    if (verbose)
                        std::cout << "process_edge returned " << coordinates.size() << " solutions\n";
                    for (uint k = 0; k < coordinates.size(); ++k)
                    {
                        double u = coordinates[k];
                        found[i].push_back((1. - u) * einfo.first.pos + u * einfo.second.pos);
                    }
                    if (verbose)
                        std::cout << "Found now contains " << found.size() << " entries\n";
                    all_processed_edges[edgeid] = found[i];
                }
                else if (result.first == criterion_underflow)
                {
                    if (verbose)
                        std::cout << "criterion underflow\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == weak_ridge)
                {
                    if (verbose)
                        std::cout << "weak ridge\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == low_ridge)
                {
                    if (verbose)
                        std::cout << "low ridge\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == no_ridge_point)
                {
                    if (verbose)
                        std::cout << "no ridge pouint\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else
                {
                    if (verbose)
                        std::cout << "unrecognized case\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                nprocessed++;
            }

            if (found.size() >= 3)
            {
                if (verbose)
                {
                    std::cout << "After looking at all edges found contains " << found.size() << " entries\n";
                    for (auto iter = found.begin(); iter != found.end(); ++iter)
                    {
                        std::cout << "Edge #" << iter->first << " contains " << iter->second << '\n';
                    }
                }
                std::vector<triangle_type> tris;
                uint tri_case;
                if (verbose)
                    tri_case = triangulate(tris, found, std::cout);
                else
                    tri_case = triangulate(tris, found, log);

                if (tris.size() > 0)
                {
                    std::for_each(tris.begin(), tris.end(), [&](auto T)
                                {
                                    all_triangles.push_back(T);
                                    // std::cout << "\nTriangle is " << T << '\n';
                                });
                    nfixed++;
                }
                else
                {
                    if (verbose)
                        std::cout << "Triangulation failed\n";
                    nfailed++;
                    still_broken.push_back(id);
                }
            }
            else if (found.size() > 0)
            {
                nfailed++;
                still_broken.push_back(id);
            }
            else
            {
                nfailed++;
                still_broken.push_back(id);
            }
        }
        progress.end();
        std::cout << nfixed << " / " << failed_voxels.size() << " broken voxels were fixed\n";

        // subdivide remaining failed voxels
        std::vector<coord3> new_voxels;
        for (uint n=0; n<still_broken.size(); ++n)
        {
            coord3 id = still_broken[n];
            coord3 base = 2*id;
            new_voxels.push_back(base);
            new_voxels.push_back(base + coord3(1, 0, 0));
            new_voxels.push_back(base + coord3(1, 1, 0));
            new_voxels.push_back(base + coord3(0, 1, 0));
            new_voxels.push_back(base + coord3(0, 0, 1));
            new_voxels.push_back(base + coord3(1, 0, 1));
            new_voxels.push_back(base + coord3(1, 1, 1));
            new_voxels.push_back(base + coord3(0, 1, 1));
        }
        voxel_ids.swap(new_voxels);
    }

    if (!all_triangles.empty()) 
    {
        size_t sizes[3] = { 3, 3, all_triangles.size() };
        spurt::nrrd_utils::writeNrrd((void*)&all_triangles[0], output_name + "_mesh.nrrd", 
                                     nrrdTypeDouble, 3, sizes);
        std::vector<std::array<double, 2>> attributes(3*all_triangles.size());
        std::cout << "uinterpolating value and ridge strength...\n";
        std::cout << "there are " << all_triangles.size() << " triangles\n";
        for (size_t n=0; n<all_triangles.size(); ++n)
        {
            auto tri = all_triangles[n];
            for (uint k=0; k<3; ++k)
            {
                auto p = tri[k];
                // compute value and ridge strength at that position
                auto v = values.evaluate(p);
                auto h = hessians.evaluate(p);
                auto l3_ev3 = evmin(h);
                attributes[3*n+k] = {v, l3_ev3.first};
            }
        }
        std::cout << "\ndone\n";
        sizes[0] = 2;
        spurt::nrrd_utils::writeNrrd((void*)&attributes[0], output_name + "_attributes.nrrd",
                                     nrrdTypeDouble, 3, sizes);
        export_triangles(all_triangles, attributes, output_name + "_polydata.vtp");
    }
    else 
    {
        std::cout << "No triangles found\n";
    }

    if (!rejected.empty()) 
    {
        size_t sizes[2] = { 4, rejected.size() };
        spurt::nrrd_utils::writeNrrd((void*)&rejected[0], "rejected.nrrd", nrrdTypeDouble, 2, sizes);
    }
    else 
    {
        std::cout << "No rejected pouints\n";
    }

    return 0;
}
