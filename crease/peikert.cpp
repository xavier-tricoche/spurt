// STL
#include <cmath>
#include <array>
#include <exception>
#include <algorithm>
#include <utility>
#include <fstream>
#include <regex>
// Boost
#include <boost/math/interpolators/cardinal_cubic_b_spline.hpp>
#include <boost/multi_array.hpp>
// Eigen
#include <Eigen/Eigen>
// Teem
#include <teem/nrrd.h>
// spurt
#include <misc/option_parse.hpp>
#include <image/nrrd_wrapper.hpp>
#include <misc/progress.hpp>
#include <spline/spline.h>

// idea: store all ridge points, weak or even numbered with a
// corresponding code to indicate why they were not included for
// triangulation and upon running into a pathological case
// figure out if some of these points should have been used anyway,
// and, if so, how to make that determination ahead of time, if at
// all possible.

// Edges containing multiple ridge points need to be refined, yielding 2 edges that are shared by 4 
// regular voxels or 8 refined voxels. 
// Algorithm:
// - If an edge is found to have 2 or more rige points:
//    all its surrounding voxels are marked for subdivision.
// - Afterwards: 
//    all unique subdivision voxels are processed and subdivided as needed

int verbose = 1;

constexpr int criterion_underflow = -10;
constexpr int determinant_underflow = -20;
constexpr int weak_ridge = -30;
constexpr int low_ridge = -40;
constexpr int several_ridge_points = -50;
constexpr int no_ridge_points = -1;
constexpr int unknown_error = -100;
constexpr int one_ridge_points = 0;

constexpr int one_triangle = 1;
constexpr int valid_mc_case = 2;
constexpr int invalid_mc_case = 3;
constexpr int exotic_case = 4;
constexpr int not_enough_edges = 5;

typedef Eigen::Matrix<double, 3, 1> vec3;
typedef Eigen::Matrix<int, 3, 1> ivec3;
typedef Eigen::Matrix<double, 3, 3> mat3;
typedef Eigen::Matrix<int, Eigen::Dynamic, Eigen::Dynamic> dyn_mat_type;
typedef Eigen::SelfAdjointEigenSolver<mat3> eigensolver_type;
typedef boost::multi_array<double, 3> scalar_raster;
typedef boost::multi_array<vec3, 3> vector_raster;
typedef boost::multi_array<mat3, 3> matrix_raster;
typedef Eigen::Matrix<double, 4, 1> vec4;

typedef Eigen::Vector<int, 3> CoordID;
struct CoordLexico
{
    bool operator()(const CoordID &c0, const CoordID &c1) const
    {
        if (c0[0] < c1[0])
            return true;
        else if (c1[0] < c0[0])
            return false;
        else if (c0[1] < c1[1])
            return true;
        else if (c1[1] < c0[1])
            return false;
        else
            return (c0[2] < c1[2]);
    }
};

constexpr double invalid = std::numeric_limits<double>::max();

int vertices[][3] = { {0, 0, 0}, {1, 0, 0}, {1, 1, 0}, {0, 1, 0 },
                { 0, 0, 1 }, { 1, 0, 1 }, { 1, 1, 1 }, { 0, 1, 1 } };

int edges[][4] = { { 0, 2, 4, 6 }, { 3, 7, 1, 5 }, { 8, 9, 11, 10 } };

int canonical_edge_coordinates[][2][3] = 
        { {{ 0, 0, 0 }, { 1, 0, 0 }}, // 0
          {{ 1, 0, 0 }, { 1, 1, 0 }}, // 1
          {{ 0, 1, 0 }, { 1, 1, 0 }}, // 2 
          {{ 0, 0, 0 }, { 0, 1, 0 }}, // 3
          {{ 0, 0, 1 }, { 1, 0, 1 }}, // 4
          {{ 1, 0, 1 }, { 1, 1, 1 }}, // 5
          {{ 0, 1, 1 }, { 1, 1, 1 }}, // 6
          {{ 0, 0, 1 }, { 0, 1, 1 }}, // 7
          {{ 0, 0, 0 }, { 0, 0, 1 }}, // 8
          {{ 1, 0, 0 }, { 1, 0, 1 }}, // 9
          {{ 1, 1, 0 }, { 1, 1, 1 }}, // 10
          {{ 0, 1, 0 }, { 0, 1, 1 }} }; // 11

int canonical_edge_indices[][2] = {
    {0, 1}, {1, 2}, {2, 3}, {3, 0}, 
    {4, 5}, {5, 6}, {6, 7}, {7, 4},
    {0, 4}, {1, 5}, {2, 6}, {3, 7}
};

char triTable[256][16] ={
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 0
     {0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 1
     {0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 2
     {1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 3
     {1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 4
     {0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 5
     {9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 6
     {2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1},        // 7
     {3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},   // 8
     {0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},     // 9
     {1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 10
     {1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1},       // 11
     {3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 12
     {0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 13
     {3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1},       // 14
     {9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 15
     {4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 16
     {4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 17
     {0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 18
     {4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1},          // 19
     {1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 20
     {3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1},         // 21
     {9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},         // 22
     {2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1},            // 23
     {8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 24
     {11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1},        // 25
     {9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},         // 26
     {4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1},          // 27
     {3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1},       // 28 
     {1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1},         // 29
     {4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1},         // 30
     {4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1},      // 31
     {9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 32
     {9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 33
     {0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},       // 34
     {8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1},          // 35
     {1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 36
     {3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},         // 37
     {5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1},         // 38
     {2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1},            // 39
     {9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 40
     {0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1},
     {2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1},
     {10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1},          // 45
     {5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1},
     {5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1},          // 50
     {1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1},
     {8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1},
     {2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1},         // 55
     {7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1},
     {11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1},          // 60
     {5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1},
     {11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1},
     {11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 65
     {9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1},
     {9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1},          // 70
     {5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1},          // 75
     {6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1},
     {6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 80
     {4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1},
     {10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1},
     {6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1},             // 85
     {8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1},
     {7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1},
     {3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1},
     {5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1},
     {0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1},           // 90
     {9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1},
     {8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1},
     {5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1},
     {0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1},
     {6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1},           // 95
     {10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1},
     {10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1},          // 100     
     {3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1},
     {0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1},          // 105
     {3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1},
     {6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1},
     {9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1},
     {8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1},
     {3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1},         // 110
     {6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1},
     {10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1},
     {10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1},        // 115 
     {1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1},
     {2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1},
     {7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1},
     {7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1},          // 120
     {2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1},
     {1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1},
     {11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1},
     {8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1},
     {0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 125
     {7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1},
     {7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 130
     {8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1},         // 135
     {7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1},
     {1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1},
     {10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1},        // 140
     {10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1},
     {0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1},
     {7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1},
     {6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1},         // 145
     {8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1},
     {9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1},
     {6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1},
     {4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1},          // 150
     {10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1},
     {8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1},
     {0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1},
     {1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1},          // 155
     {8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1},
     {10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1},
     {4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1},
     {10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 160
     {0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1},
     {9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1},
     {6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1},           // 165
     {7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1},
     {3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1},
     {7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1},
     {3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1},             // 170
     {6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1},
     {9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1},
     {1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1},
     {4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1},
     {7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1},         // 175
     {6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1},
     {0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1},
     {6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1},         // 180
     {0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1},
     {11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1},
     {6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1},
     {5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1},
     {9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1},          // 185
     {1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1},
     {1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1},
     {10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1},
     {0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 190
     {10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1},
     {5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1},
     {10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1},          // 195
     {11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1},
     {9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1},
     {7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1},
     {2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1},         // 200
     {8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1},
     {9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1},
     {9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1},
     {1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1},          // 205
     {9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1},
     {9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1},
     {0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1},         // 210
     {10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1},
     {2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1},
     {0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1},
     {0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1},
     {9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 215
     {2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1},
     {5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1},
     {3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1},
     {5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1},          // 220
     {0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1},
     {9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1},          // 225
     {1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1},
     {3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1},
     {4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1},
     {9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1},
     {11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1},        // 230
     {11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1},
     {2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1},
     {9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1},
     {3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1},
     {1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},      // 235
     {4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1},
     {4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1},
     {4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},    // 240
     {3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1},
     {0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1},
     {3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1},
     {3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1},           // 245
     {0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1},
     {9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1},           // 250
     {1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},
     {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}};// 255

int edge_code_to_case_id[4096] = {
255, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 0 - 9
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 10 - 19
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 20 - 29
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 30 - 39
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 40 - 49
-1, 221, -1, -1, -1, -1, -1, -1, -1, -1,  // 50 - 59
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 60 - 69
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 70 - 79
-1, -1, -1, -1, -1, 153, -1, -1, -1, -1,  // 80 - 89
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 90 - 99
-1, -1, 187, -1, -1, -1, -1, -1, -1, -1,  // 100 - 109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 110 - 119
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 120 - 129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 130 - 139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 140 - 149
-1, -1, -1, 238, -1, -1, -1, -1, -1, -1,  // 150 - 159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 160 - 169
204, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 170 - 179
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 180 - 189
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 190 - 199
-1, -1, -1, -1, 136, -1, -1, -1, -1, -1,  // 200 - 209
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 210 - 219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 220 - 229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 230 - 239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 240 - 249
-1, -1, -1, -1, -1, 170, -1, -1, -1, -1,  // 250 - 259
-1, -1, -1, -1, -1, 254, -1, -1, -1, -1,  // 260 - 269
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 270 - 279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 280 - 289
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 290 - 299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 300 - 309
-1, -1, -1, -1, 220, -1, -1, -1, -1, -1,  // 310 - 319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 320 - 329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 330 - 339
-1, -1, -1, -1, -1, -1, -1, -1, 152, -1,  // 340 - 349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 350 - 359
-1, -1, -1, -1, -1, -1, -1, 186, -1, -1,  // 360 - 369
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 370 - 379
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 380 - 389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 390 - 399
239, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 400 - 409
-1, -1, -1, -1, -1, -1, -1, -1, -1, 205,  // 410 - 419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 420 - 429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 430 - 439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 440 - 449
-1, -1, -1, 137, -1, -1, -1, -1, -1, -1,  // 450 - 459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 460 - 469
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 470 - 479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 480 - 489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 490 - 499
-1, -1, 171, -1, -1, -1, -1, -1, -1, -1,  // 500 - 509
-1, -1, -1, -1, -1, 253, -1, -1, -1, -1,  // 510 - 519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 520 - 529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 530 - 539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 540 - 549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 550 - 559
223, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 560 - 569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 570 - 579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 580 - 589
-1, -1, -1, -1, -1, -1, -1, -1, 155, -1,  // 590 - 599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 600 - 609
-1, -1, -1, 185, -1, -1, -1, -1, -1, -1,  // 610 - 619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 620 - 629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 630 - 639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 640 - 649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 650 - 659
-1, -1, -1, -1, -1, -1, 236, -1, -1, -1,  // 660 - 669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 670 - 679
-1, 206, -1, -1, -1, -1, -1, -1, -1, -1,  // 680 - 689
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 690 - 699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 700 - 709
-1, -1, -1, -1, -1, -1, -1, -1, -1, 138,  // 710 - 719
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 720 - 729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 730 - 739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 740 - 749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 750 - 759
-1, -1, -1, -1, 168, -1, -1, -1, -1, -1,  // 760 - 769
-1, -1, -1, -1, -1, -1, -1, -1, 252, -1,  // 770 - 779
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 780 - 789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 790 - 799
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 800 - 809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 810 - 819
-1, -1, -1, -1, -1, 222, -1, -1, -1, -1,  // 820 - 829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 830 - 839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 840 - 849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 850 - 859
-1, -1, -1, 154, -1, -1, -1, -1, -1, -1,  // 860 - 869
-1, -1, -1, -1, -1, -1, 184, -1, -1, -1,  // 870 - 879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 880 - 889
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 890 - 899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 900 - 909
-1, -1, -1, -1, -1, 237, -1, -1, -1, -1,  // 910 - 919
-1, -1, -1, -1, -1, -1, -1, -1, 207, -1,  // 920 - 929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 930 - 939
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 940 - 949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 950 - 959
-1, -1, -1, -1, -1, -1, 139, -1, -1, -1,  // 960 - 969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 970 - 979
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 980 - 989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 990 - 999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1000 - 1009
-1, -1, -1, 169, -1, -1, -1, -1, -1, -1,  // 1010 - 1019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1020 - 1029
251, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1030 - 1039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1040 - 1049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1050 - 1059
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1060 - 1069
-1, -1, -1, -1, -1, -1, -1, 217, -1, -1,  // 1070 - 1079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1080 - 1089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1090 - 1099
-1, -1, -1, -1, -1, -1, -1, 157, -1, -1,  // 1100 - 1109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1110 - 1119
191, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1120 - 1129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1130 - 1139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1140 - 1149
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1150 - 1159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1160 - 1169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1170 - 1179
-1, -1, -1, 234, -1, -1, -1, -1, -1, -1,  // 1180 - 1189
-1, -1, -1, -1, -1, -1, 200, -1, -1, -1,  // 1190 - 1199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1200 - 1209
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1210 - 1219
-1, -1, -1, -1, -1, -1, 140, -1, -1, -1,  // 1220 - 1229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1230 - 1239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1240 - 1249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1250 - 1259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1260 - 1269
-1, -1, -1, 174, -1, -1, -1, -1, -1, -1,  // 1270 - 1279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1280 - 1289
-1, -1, -1, -1, -1, 250, -1, -1, -1, -1,  // 1290 - 1299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1300 - 1309
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1310 - 1319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1320 - 1329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1330 - 1339
216, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1340 - 1349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1350 - 1359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1360 - 1369
156, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1370 - 1379
-1, -1, -1, -1, -1, 190, -1, -1, -1, -1,  // 1380 - 1389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1390 - 1399
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1400 - 1409
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1410 - 1419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1420 - 1429
235, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1430 - 1439
-1, -1, -1, -1, -1, 201, -1, -1, -1, -1,  // 1440 - 1449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1450 - 1459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1460 - 1469
-1, -1, -1, -1, -1, 141, -1, -1, -1, -1,  // 1470 - 1479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1480 - 1489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1490 - 1499
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1500 - 1509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1510 - 1519
175, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1520 - 1529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1530 - 1539
-1, 249, -1, -1, -1, -1, -1, -1, -1, -1,  // 1540 - 1549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1550 - 1559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1560 - 1569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1570 - 1579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1580 - 1589
219, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 1590 - 1599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1600 - 1609
-1, -1, -1, -1, -1, -1, 159, -1, -1, -1,  // 1610 - 1619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1620 - 1629
-1, -1, -1, -1, -1, 189, -1, -1, -1, -1,  // 1630 - 1639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1640 - 1649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1650 - 1659
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1660 - 1669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1670 - 1679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1680 - 1689
-1, -1, 232, -1, -1, -1, -1, -1, -1, -1,  // 1690 - 1699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1700 - 1709
-1, 202, -1, -1, -1, -1, -1, -1, -1, -1,  // 1710 - 1719
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1720 - 1729
-1, -1, -1, -1, -1, -1, -1, 142, -1, -1,  // 1730 - 1739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1740 - 1749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1750 - 1759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1760 - 1769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1770 - 1779
-1, -1, -1, -1, -1, -1, 172, -1, -1, -1,  // 1780 - 1789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1790 - 1799
-1, -1, -1, -1, 248, -1, -1, -1, -1, -1,  // 1800 - 1809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1810 - 1819
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1820 - 1829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1830 - 1839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1840 - 1849
-1, -1, -1, -1, -1, 218, -1, -1, -1, -1,  // 1850 - 1859
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1860 - 1869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1870 - 1879
-1, 158, -1, -1, -1, -1, -1, -1, -1, -1,  // 1880 - 1889
-1, -1, -1, -1, -1, -1, -1, -1, 188, -1,  // 1890 - 1899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1900 - 1909
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1910 - 1919
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1920 - 1929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1930 - 1939
-1, 233, -1, -1, -1, -1, -1, -1, -1, -1,  // 1940 - 1949
-1, -1, -1, -1, -1, -1, -1, -1, 203, -1,  // 1950 - 1959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1960 - 1969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1970 - 1979
-1, -1, -1, -1, 143, -1, -1, -1, -1, -1,  // 1980 - 1989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 1990 - 1999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2000 - 2009
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2010 - 2019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2020 - 2029
-1, -1, -1, -1, -1, 173, -1, -1, -1, -1,  // 2030 - 2039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2040 - 2049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2050 - 2059
247, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2060 - 2069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2070 - 2079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2080 - 2089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2090 - 2099
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2100 - 2109
-1, 213, -1, -1, -1, -1, -1, -1, -1, -1,  // 2110 - 2119
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2120 - 2129
-1, -1, -1, -1, -1, -1, -1, 145, -1, -1,  // 2130 - 2139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2140 - 2149
-1, -1, -1, -1, 179, -1, -1, -1, -1, -1,  // 2150 - 2159
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2160 - 2169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2170 - 2179
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2180 - 2189
-1, -1, -1, -1, -1, -1, -1, 230, -1, -1,  // 2190 - 2199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2200 - 2209
-1, -1, -1, -1, 196, -1, -1, -1, -1, -1,  // 2210 - 2219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2220 - 2229
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2230 - 2239
128, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2240 - 2249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2250 - 2259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2260 - 2269
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2270 - 2279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2280 - 2289
-1, 162, -1, -1, -1, -1, -1, -1, -1, -1,  // 2290 - 2299
-1, -1, -1, -1, -1, -1, -1, -1, -1, 246,  // 2300 - 2309
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2310 - 2319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2320 - 2329
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2330 - 2339
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2340 - 2349
-1, -1, -1, -1, -1, -1, -1, -1, 212, -1,  // 2350 - 2359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2360 - 2369
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2370 - 2379
-1, -1, -1, -1, 144, -1, -1, -1, -1, -1,  // 2380 - 2389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2390 - 2399
-1, -1, -1, 178, -1, -1, -1, -1, -1, -1,  // 2400 - 2409
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2410 - 2419
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2420 - 2429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2430 - 2439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2440 - 2449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2450 - 2459
231, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2460 - 2469
-1, -1, -1, -1, -1, -1, -1, -1, -1, 197,  // 2470 - 2479
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2480 - 2489
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2490 - 2499
-1, -1, -1, -1, -1, 129, -1, -1, -1, -1,  // 2500 - 2509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2510 - 2519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2520 - 2529
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2530 - 2539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2540 - 2549
-1, -1, -1, -1, 163, -1, -1, -1, -1, -1,  // 2550 - 2559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2560 - 2569
-1, -1, -1, -1, -1, 245, -1, -1, -1, -1,  // 2570 - 2579
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2580 - 2589
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2590 - 2599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2600 - 2609
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2610 - 2619
215, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2620 - 2629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2630 - 2639
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2640 - 2649
147, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2650 - 2659
-1, -1, -1, -1, -1, 177, -1, -1, -1, -1,  // 2660 - 2669
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2670 - 2679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2680 - 2689
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2690 - 2699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2700 - 2709
228, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2710 - 2719
-1, -1, -1, -1, -1, 198, -1, -1, -1, -1,  // 2720 - 2729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2730 - 2739
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2740 - 2749
-1, -1, -1, -1, -1, 130, -1, -1, -1, -1,  // 2750 - 2759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2760 - 2769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2770 - 2779
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2780 - 2789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2790 - 2799
160, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 2800 - 2809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2810 - 2819
-1, -1, 244, -1, -1, -1, -1, -1, -1, -1,  // 2820 - 2829
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2830 - 2839
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2840 - 2849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2850 - 2859
-1, -1, -1, -1, -1, -1, -1, -1, -1, 214,  // 2860 - 2869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2870 - 2879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2880 - 2889
-1, -1, -1, -1, -1, -1, -1, -1, -1, 146,  // 2890 - 2899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2900 - 2909
-1, -1, 176, -1, -1, -1, -1, -1, -1, -1,  // 2910 - 2919
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2920 - 2929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2930 - 2939
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2940 - 2949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2950 - 2959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2960 - 2969
-1, -1, -1, -1, -1, 229, -1, -1, -1, -1,  // 2970 - 2979
-1, -1, -1, -1, -1, -1, -1, -1, 199, -1,  // 2980 - 2989
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 2990 - 2999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3000 - 3009
-1, -1, -1, -1, -1, -1, -1, -1, 131, -1,  // 3010 - 3019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3020 - 3029
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3030 - 3039
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3040 - 3049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3050 - 3059
-1, -1, -1, -1, -1, 161, -1, -1, -1, -1,  // 3060 - 3069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3070 - 3079
-1, -1, 243, -1, -1, -1, -1, -1, -1, -1,  // 3080 - 3089
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3090 - 3099
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3100 - 3109
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3110 - 3119
-1, -1, -1, -1, -1, -1, -1, -1, -1, 209,  // 3120 - 3129
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3130 - 3139
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3140 - 3149
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3150 - 3159
-1, -1, -1, -1, -1, -1, -1, 149, -1, -1,  // 3160 - 3169
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3170 - 3179
183, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3180 - 3189
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3190 - 3199
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3200 - 3209
-1, -1, -1, -1, -1, -1, -1, -1, -1, 226,  // 3210 - 3219
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3220 - 3229
-1, -1, 192, -1, -1, -1, -1, -1, -1, -1,  // 3230 - 3239
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3240 - 3249
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3250 - 3259
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3260 - 3269
132, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3270 - 3279
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3280 - 3289
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3290 - 3299
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3300 - 3309
-1, -1, -1, -1, -1, -1, -1, 166, -1, -1,  // 3310 - 3319
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3320 - 3329
-1, 242, -1, -1, -1, -1, -1, -1, -1, -1,  // 3330 - 3339
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3340 - 3349
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3350 - 3359
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3360 - 3369
-1, -1, -1, -1, -1, -1, 208, -1, -1, -1,  // 3370 - 3379
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3380 - 3389
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3390 - 3399
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3400 - 3409
-1, -1, -1, -1, 148, -1, -1, -1, -1, -1,  // 3410 - 3419
-1, -1, -1, -1, -1, -1, -1, -1, -1, 182,  // 3420 - 3429
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3430 - 3439
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3440 - 3449
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3450 - 3459
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3460 - 3469
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3470 - 3479
-1, -1, 227, -1, -1, -1, -1, -1, -1, -1,  // 3480 - 3489
-1, -1, -1, -1, -1, -1, -1, 193, -1, -1,  // 3490 - 3499
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3500 - 3509
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3510 - 3519
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3520 - 3529
-1, -1, -1, -1, -1, 133, -1, -1, -1, -1,  // 3530 - 3539
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3540 - 3549
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3550 - 3559
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3560 - 3569
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3570 - 3579
167, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3580 - 3589
-1, -1, -1, 241, -1, -1, -1, -1, -1, -1,  // 3590 - 3599
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3600 - 3609
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3610 - 3619
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3620 - 3629
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3630 - 3639
-1, -1, 211, -1, -1, -1, -1, -1, -1, -1,  // 3640 - 3649
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3650 - 3659
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3660 - 3669
-1, -1, -1, -1, -1, -1, 151, -1, -1, -1,  // 3670 - 3679
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3680 - 3689
-1, -1, -1, -1, -1, 181, -1, -1, -1, -1,  // 3690 - 3699
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3700 - 3709
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3710 - 3719
-1, -1, -1, -1, -1, -1, -1, -1, 224, -1,  // 3720 - 3729
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3730 - 3739
-1, -1, -1, -1, -1, -1, -1, 194, -1, -1,  // 3740 - 3749
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3750 - 3759
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3760 - 3769
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3770 - 3779
-1, 134, -1, -1, -1, -1, -1, -1, -1, -1,  // 3780 - 3789
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3790 - 3799
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3800 - 3809
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3810 - 3819
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3820 - 3829
164, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3830 - 3839
240, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 3840 - 3849
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3850 - 3859
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3860 - 3869
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3870 - 3879
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3880 - 3889
-1, 210, -1, -1, -1, -1, -1, -1, -1, -1,  // 3890 - 3899
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3900 - 3909
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3910 - 3919
-1, -1, -1, -1, -1, 150, -1, -1, -1, -1,  // 3920 - 3929
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3930 - 3939
-1, -1, 180, -1, -1, -1, -1, -1, -1, -1,  // 3940 - 3949
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3950 - 3959
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3960 - 3969
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3970 - 3979
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 3980 - 3989
-1, -1, -1, 225, -1, -1, -1, -1, -1, -1,  // 3990 - 3999
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4000 - 4009
195, -1, -1, -1, -1, -1, -1, -1, -1, -1,  // 4010 - 4019
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4020 - 4029
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4030 - 4039
-1, -1, -1, -1, 135, -1, -1, -1, -1, -1,  // 4040 - 4049
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4050 - 4059
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4060 - 4069
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4070 - 4079
-1, -1, -1, -1, -1, -1, -1, -1, -1, -1,   // 4080 - 4089
-1, -1, -1, -1, -1, 165 }; // 4090 - 4095

template<typename V>
struct ValueFiller {};

template<>
struct ValueFiller<double> {
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    double operator()(const wrapper_type& w, size_t i, size_t stride) {
        return w[i];
    }
};

template<>
struct ValueFiller<vec3> {
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    vec3 operator()(const wrapper_type& w, size_t i, size_t stride) {
        return vec3(w[i], w[i+stride], w[i+2*stride]);
    } 
};

template <>
struct ValueFiller<mat3>
{
    typedef spurt::nrrd_utils::nrrd_data_wrapper<double> wrapper_type;
    mat3 operator()(const wrapper_type &w, size_t i, size_t stride)
    {
        return mat3({ {w[i],          w[i+stride],   w[i+2*stride]},
                      {w[i+3*stride], w[i+4*stride], w[i+5*stride]},
                      {w[i+6*stride], w[i+7*stride], w[i+8*stride]} });
    }
};

template<typename T=double, typename V=T, typename Filler=ValueFiller<V> >
struct BlockOfValues {
    typedef T scalar_type;
    typedef V value_type;
    typedef spurt::nrrd_utils::nrrd_data_wrapper<T> wrapper_type;
    typedef BlockOfValues<scalar_type, value_type> self_type;
    typedef Filler filler_type;

    BlockOfValues() : m_sizes(), m_data() {}

    /*
        M x N x P x 3
        id[i,j,k][0] = i + size[0]*(j + size[1]*(k + size[2]*0))
        id[i,j,k][l] = i + size[0]*(j + size[1]*(k + size[2]*l))

        i + j*size[0] + k*size[0]*size[1] + l*size[0]*size[1]*size[2]


    */

    BlockOfValues(Nrrd *nin)
    {
        wrapper_type wrap(nin);
        bool is_scalar = (nin->dim == 3);

        // figure out how the data is stored
        int outerstride = 1;
        int innerstride = 1;
        int spacemin=0;
        if (!is_scalar) {
            if (nin->dim == 4) {
                if (nin->axis[0].size <= 9) {
                    // individual scalar entries are in innermost dim
                    spacemin = 1;
                    outerstride = nin->axis[0].size;
                    innerstride = 1;
                }
                else if (nin->axis[3].size <= 9) {
                    // individual scalar entries are in outermost dim
                    spacemin = 0;
                    innerstride = nin->axis[0].size*nin->axis[1].size*nin->axis[2].size;
                    outerstride = 1;
                }
                else {
                    throw std::runtime_error("Unrecognized Nrrd shape");
                }
            }
            else if (nin->dim == 5) {
                if (nin->axis[0].size*nin->axis[1].size <= 9) {
                    // individual scalar entries are in innermost dim
                    spacemin = 2;
                    outerstride = nin->axis[0].size*nin->axis[1].size;
                    innerstride = 1;
                }
                else if (nin->axis[3].size*nin->axis[4].size <= 9) {
                    // individual scalar entries are in outermost dim
                    spacemin = 0;
                    innerstride = nin->axis[0].size*nin->axis[1].size*nin->axis[2].size;
                    outerstride = 1;
                }
                else {
                    throw std::runtime_error("Unrecognized Nrrd shape");
                }
            }
        }
        m_sizes = { nin->axis[spacemin].size, 
                    nin->axis[spacemin+1].size, 
                    nin->axis[spacemin+2].size };
        m_origin = vec3(0,0,0);
        m_spacings = vec3(1,1,1);
        for (int d=0; d<3; ++d)
        {
            if (!std::isnan(nin->axis[spacemin+d].min))
            {
                m_origin[d] = nin->axis[spacemin+d].min;
            }
            if (!std::isnan(nin->axis[spacemin+d].spacing))
            {
                m_spacings[d] = nin->axis[spacemin+d].spacing;
            }
        }
        size_t nvalues = m_sizes[0] * m_sizes[1] * m_sizes[2];

        m_data.resize(nvalues);
        filler_type filler;
        for (size_t i=0; i<nvalues; ++i) {
            size_t idx = outerstride*i;
            m_data[i] = filler(wrap, idx, innerstride);
        }
    }

    self_type& operator=(const self_type& other) {
        m_sizes = other.m_sizes;
        m_data = other.m_data;
        m_spacings = other.m_spacings;
        m_origin = other.m_origin;
        return *this;
    }

    value_type& operator()(int i, int j, int k) {
        return m_data[i + m_sizes[0] * (j + m_sizes[1] * k)];
    }

    value_type operator()(int i, int j, int k) const {
        return m_data[i + m_sizes[0] * (j + m_sizes[1] * k)];
    }

    value_type& operator()(const CoordID& c) 
    {
        return (*this)(c[0], c[1], c[2]);
    }

    value_type operator()(const CoordID& c) const
    {
        return (*this)(c[0], c[1], c[2]);
    }

    value_type evaluate(double x, double y, double z) const 
    {
        // convert to local (fractional) index coordinates
        vec3 p = (vec3(x,y,z).array() / m_spacings.array()).matrix();
        ivec3 cellid = p.cast<int>();
        for (int d=0; d<3; ++d)
        {
            cellid[d] = std::min(cellid[d], m_sizes[d]-2);
        }

        double u = p[0] - cellid[0];
        double v = p[1] - cellid[1];
        double w = p[2] - cellid[2];
        return (1. - u) * (1. - v) * (1. - w) * (*this)(cellid[0],     cellid[1],     cellid[2]    ) + 
                     u  * (1. - v) * (1. - w) * (*this)(cellid[0] + 1, cellid[1],     cellid[2]    ) +
                     u  *       v  * (1. - w) * (*this)(cellid[0] + 1, cellid[1] + 1, cellid[2]    ) +
               (1. - u) *       v  * (1. - w) * (*this)(cellid[0],     cellid[1] + 1, cellid[2]    ) +
               (1. - u) * (1. - v) *       w  * (*this)(cellid[0],     cellid[1],     cellid[2] + 1) + 
                     u  * (1. - v) *       w  * (*this)(cellid[0] + 1, cellid[1],     cellid[2] + 1) +
                     u  *       v  *       w  * (*this)(cellid[0] + 1, cellid[1] + 1, cellid[2] + 1) + 
               (1. - u) *       v  *       w  * (*this)(cellid[0],     cellid[1] + 1, cellid[2] + 1);
    }

    value_type evaluate(const vec3& p) const
    {
        return this->evaluate(p[0], p[1], p[2]);
    }

    const ivec3& shape() const {
        return m_sizes;
    }

    ivec3 m_sizes;
    std::vector<value_type> m_data;
    vec3 m_spacings;
    vec3 m_origin;
};
typedef BlockOfValues<double> BlockOfScalars;
typedef BlockOfValues<double, vec3> BlockOfVectors;
typedef BlockOfValues<double, mat3> BlockOfMatrices;

template<typename Array>
void import_nrrd(Array& out, const std::string& filename)
{
    Nrrd* nin = nrrdNew();

    if (nrrdLoad(nin, filename.c_str(), NULL))
    {
        char* err = biffGetDone(NRRD);
        std::cerr << "Peikert ridge method: " << err << std::endl;
        exit(-1);
    }

    out = Array(nin);
}

template<typename T>
T sign(const T& value) {
    if (value >= 0) return T(1);
    else return T(-1);
}


int distance(const CoordID& c0, const CoordID& c1) {
    return (c1-c0).lpNorm<Eigen::Infinity>();
}

struct EdgeID 
{
    EdgeID(const CoordID& c0, const CoordID& c1)
        : m_c0(c0), m_c1(c1) {
        CoordLexico less;
        if (less(c1, c0)) {
            m_c1 = c0;
            m_c0 = c1;
        }
    }

    bool operator<(const EdgeID& other) const {
        CoordLexico less;
        if (less(m_c0, other.m_c0)) return true;
        else if (less(other.m_c0, m_c0)) return false;
        else return less(m_c1, other.m_c1);
    }

    CoordID& operator[](int i) {
        if (i==0) {
            return m_c0;
        }
        else if (i==1) {
            return m_c1;
        }
        else {
            throw std::runtime_error("Invalid index for EdgeID");
        }
    }

    const CoordID& operator[](int i) const {
        if (i == 0)
        {
            return m_c0;
        }
        else if (i == 1)
        {
            return m_c1;
        }
        else
        {
            throw std::runtime_error("Invalid index for EdgeID");
        }
    }

    CoordID m_c0, m_c1;
};

std::ostream& operator<<(std::ostream& os, const CoordID& id) {
    os << "[" << id[0] << "," << id[1] << "," << id[2] << "]";
    return os;
} 

std::ostream &
operator<<(std::ostream &os, const EdgeID &e)
{
    os << "[" << e.m_c0 << " - " << e.m_c1 << "]";
    return os;
}

std::ostream & operator<<(std::ostream& os, const vec3& v) {
    os << "[" << v[0] << "," << v[1] << "," << v[2] << "]";
    return os;
}

std::ostream & operator<<(std::ostream& os, const mat3& m) {
    os << "[" << m.col(0) << "," << m.col(1) << "," << m.col(2) << "]";
    return os;
}

template<typename T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& v) {
    os << "[";
    if (v.size() > 0) 
    {
        for (int i=0; i<v.size()-1; ++i) os << v[i] << ", ";
        os << v.back();
    }
    os << "]";
    return os;
}

template<typename T>
T invlinear(const T& f0, const T& f1, double umin=0, double umax=1) {
    // f = f0 + (u - umin) / (umax - umin) * (f1 - f0)
    // f = 0 <=> -f0 / (f1 - f0) = (u - umin) / (umax - umin)
    // f = 0 <=> u = -f0 / (f1 - f0) * (umax - umin) + umin    
    return umin - f0/(f1-f0)*(umax-umin);
}

template<typename T>
T linear(double u, const T& v0, const T& v1) {
    return (1.-u)*v0 + u*v1;
}

std::pair<double, vec3> evmin(const mat3& H) {
    eigensolver_type solver;
    solver.compute(H);
    return std::make_pair(solver.eigenvalues()[0], solver.eigenvectors().col(0));
}

std::pair<vec3, mat3> evall(const mat3& H) {
    eigensolver_type solver;
    solver.compute(H);
    return std::make_pair(solver.eigenvalues(), solver.eigenvectors());
}

double determinant(const vec3& g, const mat3& H, bool normalize=false) {
    mat3 A;
    A.col(0) = g;
    A.col(1) = H * g;
    A.col(2) = H * A.col(1);

    if (normalize) {
        A.col(0) /= g.norm();
        A.col(1) /= A.col(1).norm();
        A.col(2) /= A.col(2).norm();
    }
    return A.determinant();
};

template<typename T>
class LinearFunction {
public:
    typedef T value_type;

    LinearFunction() : m_v0(), m_v1() {}

    LinearFunction(const value_type& val0, const value_type& val1) :
        m_v0(val0), m_v1(val1) {}

    value_type operator()(double u) const {
        return linear(u, m_v0, m_v1);
    }

private:
    value_type m_v0, m_v1;
};

typedef LinearFunction<double> scalar_function;
typedef LinearFunction<vec3> vector_function;
typedef LinearFunction<mat3> matrix_function;

class C0Criterion {
public:
    C0Criterion(const vector_function& gfunc, const matrix_function& hfunc) {
        m_gfunc = gfunc;
        m_hfunc = hfunc;
    }

    double operator()(double u) const {
        auto g = m_gfunc(u);
        auto h = m_hfunc(u);
        return determinant(g, h);
    }
private:
    vector_function m_gfunc;
    matrix_function m_hfunc;
};

template<typename Func>
double find_zero_crossing(const Func& func, double umin = 0, double umax = 1, double eps=1.0e-12, int maxn=100) {
    // print('find zero crossing')
    double fmin = func(umin);
    double fmax = func(umax);
    if (fmin * fmax >= 0) return -1;
    // det(0) * det(1) < 0

    double f = 1;  // default value
    double u;
    for (int n=0; ((umax - umin) > 1.0e-9 or std::fabs(f) > eps) and n < maxn; ++n) {
        u = 0.5 * (umin + umax);
        f = func(u);
        if (fmin*f < 0) {
            umax = u;
            fmax = f;
        } 
        else {
            umin = u; 
            fmin = f;
        } 
    }
    return u;
}

std::pair<vec3, double> project(const vec3& g, const mat3& h) {
    auto r = evall(h);
    vec3 evals = r.first;
    mat3 evecs = r.second;
    vec3 coords = (evecs.transpose()*g).array().abs().matrix();
    return std::make_pair(coords, evals[0]);
}

bool check_solution(double u, const vector_function& gfunc, const matrix_function& hfunc,
                    bool verbose=false) {
    auto r = evall(hfunc(u));
    vec3 evals = r.first;
    mat3 evecs = r.second;
    vec3 coords = (evecs.transpose()*gfunc(u)).array().abs().matrix();
    if (verbose) {
        std::cout << "eigenvalues: " << evals << '\n'
        << "eigenvectors: " << evecs << '\n'
        << "coordinates: " << coords << '\n';
    }

    Eigen::Index which;
    double minval = coords.minCoeff(&which);
    return (which == 0) && minval < 1.0e-6*coords.mean();
}

template<typename T, size_t N>
std::ostream& operator<<(std::ostream& os, const std::array<T,N>& a) {
    os << "[";
    for (int i=0; i<N-1; ++i) {
        os << a[i] << ", ";
    }
    os << a[N-1] << "]";
    return os;
}

int case_number(const std::array<bool, 12>& edges) {
    std::cout << "edges=" << edges << '\n';
    std::array<int, 8> states({{0, 0, 0, 0, 0, 0, 0, 0}});
    // 0: not set
    // -1 or 1: positive or negative value
    states[0] = -1; // arbitrary initialization
    // The following order ensures that vertices are visited in order
    int edges_order[] = {0, 1, 2, 8, 9, 10, 11, 3, 4, 5, 6, 7};
    for (int e = 0; e < 12; ++e)
    {
        int edgeid = edges_order[e];
        auto v0 = canonical_edge_indices[edgeid][0];
        auto v1 = canonical_edge_indices[edgeid][1];
        if (v0 > v1)
        {
            std::swap(v0, v1);
        }
        if (e < 7)
        {
            if (edges[edgeid])
                states[v1] = -states[v0];
            else
                states[v1] = states[v0];
        }
        else
        {
            if ((edges[edgeid] && edges[v1] * edges[v0] > 0) ||
                (!edges[edgeid] && edges[v1] * edges[v0] < 0))
                return -1; // failed
        }
        std::cout << "e=" << e << ", edgeid=" << edgeid << ", states=" << states << '\n';
    }

    int cn = 0;
    for (int i = 0; i < 8; ++i)
    {
        if (states[i] > 0)
        {
            cn += 1 << i;
        }
    }
    return cn;
}

typedef std::array<vec3, 3> triangle_type;
int triangulate(std::vector<triangle_type>& out, 
                 std::map<int, std::vector<vec3>> &edges, 
                 std::ostream& os)
{
    os << "triangles: edges contains " << edges.size() << " edges with ridge points\n";
    out.clear();

    std::map<int, int> edge_to_nbsols;
    int nbsols = 0;
    for (auto iter=edges.begin(); iter!=edges.end(); ++iter) 
    {
        edge_to_nbsols[iter->first] = iter->second.size();
        nbsols += iter->second.size();
    }

    os << "There are " << nbsols << " ridge points over " << edges.size() << " in total\n";

    // if we only have 3 or less points, things are easy
    if (edges.size() == 3 && nbsols == 3) 
    {
        triangle_type T;
        int i=0;
        for (auto iter=edges.begin(); iter!=edges.end(); ++iter, ++i) 
        {
            T[i] = iter->second[0];
        }
        out.push_back(T);
        os << "3 points on 3 edges: success!\n";
        return one_triangle;
    }
    else if (edges.size() < 3)
    {
        os << "We have only 2 (or less) edges in input of triangulation.\n"
           << "Giving up (Case N<3)\n";
        return not_enough_edges;
    }
    // If we have several points on one edge and two edges, 
    // we could triangulate put that implies finding a ridge 
    // that ends in this voxel.
    /*
        ------X---- 
       |    / |    |
       |   /  |    |
       |  /   |    |
        --X---X----
    */

    if (nbsols == edges.size()) 
    {
        // Calculate edge case number
        int edge_case = 0;
        for (auto iter=edges.begin(); iter!=edges.end(); ++iter) 
        {
            edge_case += 1 << iter->first;
        }
        os << "edge_case = " << edge_case << '\n';
        int triangle_case = edge_code_to_case_id[edge_case];
        os << "triangle_case = " << triangle_case << '\n';

        if (triangle_case == -1) // invalid
        {
            os << "the edges do not match a valid MC case...\n Giving up. (Case NoMC)\n";
            return invalid_mc_case;
        }

        auto indices = triTable[triangle_case];
        for (int i=0; i<15 && indices[i]!=-1; i+=3) 
        {
            out.push_back(triangle_type({{edges[indices[i]][0], edges[indices[i+1]][0], edges[indices[i+2]][0]}}));
            const triangle_type& t = out.back();
            os << "added triangle: " << t << '\n';
        }
        os << "A valid MC case was found and " << out.size() << " triangles "
           << "were created.\n";
        return valid_mc_case;
    }
    else
    {
        // 3 or more edges, some of which have several points
        // for now, do nothing
        return exotic_case;
    }
}

void fit_spline(tk::spline& spline, const std::vector<double>& u, C0Criterion& f) {
    std::vector<double> values;
    std::for_each(u.begin(), u.end(), [&](double x){ values.push_back(f(x)); });
    spline.set_points(u, values);
}

std::vector<double> bisection_spline_local_extremum(tk::spline &, double, double, bool);

std::vector<double> newton_spline_local_extremum(tk::spline &spline, double u0, double u1, bool verbose)
{
    // Newton:
    // f(x+dx) = 0 = f(x) + f'(x)dx <=> dx = -f(x)/f'(x)
    double f0 = spline(u0);
    double f1 = spline(u1);
    double u = -f0/(f1-f0); // initial guess (linear solution)
    double f = spline.deriv(1, u);
    int iter = 0;
    std::vector<double> all_us;
    if (verbose)
    {
        std::cout << "Looking for local extremum\n";
    }
    while (std::abs(f) > 1.0e-6 && iter < 10)
    {
        double d2f = spline.deriv(2, u);
        all_us.push_back(u);
        if (d2f == 0)
        {
            if (verbose) std::cout << "vanishing 2nd derivative: resorting to bisection\n";
            return bisection_spline_local_extremum(spline, u0, u1, verbose);
        }
        double dx = -f / d2f;
        double uu = u + dx;
        if (uu > u1) u = u1;
        else if (uu < u0) u = u0;
        else u = uu;
        if (verbose)
        {
            std::cout << "u=" << u << ", df/dt=" << f << ", d2f/dt2=" << d2f << ", dx=" << dx << '\n';
        }
        f = spline.deriv(1, u);
        if (verbose)
        {
            std::cout << "df/dt=" << f << '\n';
        }
        iter += 1;
    }
    return all_us;
}

std::vector<double> bisection_spline_local_extremum(tk::spline& spline, double u0, double u1, bool verbose) 
{
    double f0 = spline.deriv(1, u0);
    double f1 = spline.deriv(1, u1);
    double u, t;
    std::vector<double> all_us;
    for (int i=0; i<10; ++i) 
    {
        t = -f0/(f1-f0);
        u = (1-t)*u0 + t*u1;
        all_us.push_back(u);
        double f = spline.deriv(1, u);
        if (verbose)
        {
            std::cout << "bisection search: iteration " << i << ", df/dt=" << f << ", u0=" << u0 << ", u1=" << u1 << '\n';
        }
        if (f*f0 > 0)
        {
            u0 = u;
            f0 = f;
        }
        else
        {
            u1 = u;
            f1 = f;
        }
    }
    t = -f0/(f1-f0);
    u = (1 - t) * u0 + t * u1;
    all_us.push_back(u);
    double f = spline.deriv(1, u);
    if (verbose)
    {
        std::cout << "final derivative: " << f << '\n';
    }
    return all_us;
}

std::pair<int, std::vector<double>>
analyze_edge(const EdgeID &e,
             const BlockOfVectors &gradient,
             const BlockOfMatrices &hessian,
             const BlockOfScalars &data,
             bool verbose = false,
             const int sampling_res = 10,
             const double delta = 0.05,
             const double mind = 0.001,
             const double min_value = 0,
             const double min_strength = 1.0e-9,
             const double min_criterion = 1.0e-9,
             const double min_determinant = 1.0e-9)
{

    CoordID vs[2];
    vec3 gs[2];
    mat3 hs[2];
    double fs[2];
    double cs[2];
    double lmins[2];
    for (int i=0; i<2; ++i) {
        hs[i] = hessian(e[i][0], e[i][1], e[i][2]);
        gs[i] = gradient(e[i][0], e[i][1], e[i][2]);
        fs[i] = data(e[i][0], e[i][1], e[i][2]);
        cs[i] = determinant(gs[i], hs[i]);
        lmins[i] = evmin(hs[i]).first;
    }
    
    vector_function gfunc = vector_function(gs[0], gs[1]);
    matrix_function hfunc = matrix_function(hs[0], hs[1]);
    C0Criterion cfunc(gfunc, hfunc);
    
    double du = 1./static_cast<double>(sampling_res-1);
    std::map<double, double> values;
    std::vector<double> xs;
    
    for (int i=0; i<sampling_res; ++i) {
        xs.push_back(std::min(i*du, 1.));
    }
    tk::spline init_spline;
    fit_spline(init_spline, xs, cfunc);
    std::vector<double> derivs;
    for (int i=0; i<xs.size(); ++i) {
        derivs.push_back(init_spline.deriv(1, xs[i]));
        values[xs[i]] = init_spline(xs[i]);
    }

    // check if derivative has constant sign in which case we are good
    double asign = sign(derivs[0]);
    std::vector<int> where;
    if (verbose)
    {
        std::cout << "sampling spline derivative along edge\n";
        std::cout << "sample #0: "  << derivs[0] << '\n';
    }
    for (int i=1; i<derivs.size(); ++i) {
        if (verbose)
        {
            std::cout << "sample #" << i << ": " << derivs[i] << '\n';
        }
        double newsign = sign(derivs[i]);
        if (asign * newsign < 0) {
            if (verbose)
            {
                std::cout << "sign change\n";
            }
            where.push_back(i-1);
            asign = newsign;
        }
    }
    if (verbose)
        std::cout << "spline derivative changed sign " << where.size() << " times\n";
    if (!where.empty()) {
        for (int i=0; i<where.size(); ++i) {
            // find root of derivative
            double u0 = xs[where[i]];
            double u1 = xs[where[i]+1];
            // double u = bisection_spline_local_extremum(init_spline, u0, u1, verbose);
            std::vector<double> new_us = newton_spline_local_extremum(init_spline, u0, u1, verbose);
            // found zero crossing of derivative
            std::for_each(new_us.begin(), new_us.end(), [&](double u)
            {
                values[u] = cfunc(u);
            });
            // for (double c=0.1; c<=0.5; c+=0.1) 
            // {
            //     double v = (1-c)*u + c*u0;
            //     values[v] = cfunc(v);
            // }
            // for (double c=0.1; c<=0.5; c+=0.1)
            // {
            //     double v = (1-c)*u + c*u1;
            //     values[v] = cfunc(v);
            // }
        }
    }

    if (verbose) {
        std::cout << "After spline-based refinement, samples are:\n";
        for (auto iter=values.begin(); iter!=values.end(); ++iter) {
            std::cout << std::setprecision(32) << iter->first << ": " << iter->second << '\n';
        }
    }

    /*
    std::vector<std::pair<double, double>> active_intervals;
    for (int i=0; i<sampling_res-1; ++i)
    {
        active_intervals.push_back(std::make_pair(i*du, std::min((i+1)*du, 1.)));
    }
    
    while (!active_intervals.empty())
    {
        std::vector<std::pair<double, double>> new_intervals;
        if (verbose)
        {
            std::cout << "Starting new linearization round\n";
            std::cout << "\t" << active_intervals.size() << " intervals to process\n";
            std::cout << "current sampled values are:\n";
            for (auto iter=values.begin(); iter!=values.end(); ++iter)
            {
                std::cout << std::setprecision(32) << iter->first << ": " << iter->second << '\n';
            }
        }
        for (int i=0; i<active_intervals.size(); ++i)
        {   
            double u0 = active_intervals[i].first;
            double u1 = active_intervals[i].second;
            if (u1-u0 < mind) {
                if (verbose)
                    std::cout << "declining to refine between " << u0 << " and " << u1 << " because their distance is smaller than " << mind << '\n';
                continue;
            }
            double f0 = values[u0];
            double f1 = values[u1];
            double u = 0.5*(u0 + u1);
            double truth = cfunc(u);
            double approx = 0.5*(f0 + f1);
            double range = std::abs(f1-f0);
            double rel_error = std::abs(approx-truth)/range;
            if (rel_error > delta)
            {
                if (verbose)
                {
                    std::cout << "section between " << std::setprecision(32) << u0 << " and " << u1 << " is nonlinear: error=" << rel_error << '\n';
                    std::cout << "interpolated value between " << std::setprecision(32) << f0 << " and " << f1 << " was " << approx << " but actual value is " << truth << '\n';
                    std::cout << "\tadding f(" << std::setprecision(32) << u << ")=" << truth << '\n';
                }
                values[u] = truth;
                new_intervals.push_back(std::make_pair(u0, u));
                new_intervals.push_back(std::make_pair(u, u1));
            }
        }
        new_intervals.swap(active_intervals);
    }
    */

    std::vector<double> ridge_points;

    for (auto iter=values.begin(); iter!=values.end(); ++iter)
    {
        auto next = iter;
        ++next;
        if (next == values.end()) break;
        double u0 = iter->first;
        double f0 = iter->second;
        double u1 = next->first;
        double f1 = next->second;
        if (f0*f1 < 0)
        {
            if (verbose) {
                std::cout << "zero crossing found between " << u0 << " and " << u1 << '\n';
            }
            double u = find_zero_crossing(cfunc, u0, u1);
            if (check_solution(u, gfunc, hfunc, verbose))
            {
                if (verbose)
                    std::cout << "ridge point found\n";
                ridge_points.push_back(u);
            }
            else if (verbose) {
                std::cout << "no ridge point found\n";
            }
        }
    }

    if (ridge_points.size() == 1)
        return std::make_pair(one_ridge_points, ridge_points);
    else if (ridge_points.size() > 1)
        return std::make_pair(several_ridge_points, ridge_points);
    else
        return std::make_pair(no_ridge_points, std::vector<double>());
}

std::pair<double, double> evaluate(const vec3& point,
                                   const BlockOfScalars& values, 
                                   const BlockOfMatrices& hessian) 
{
    vec3 low;
    int dim = -1;
    for (int i=0; i<3; ++i) {
        low[i] = std::trunc(point[i]);
        if (point[i] - low[i] > 1.0e-6) { // we are working in index space
            dim = i;
        }
    }
    if (dim == -1) {
        std::ostringstream os;
        os << "Invalid edge coordinate: " << point;
        throw std::runtime_error(os.str());
    }
    vec3 high = low;
    high[dim] += 1;
    mat3 H0 = hessian(low[0], low[1], low[2]);
    double v0 = values(low[0], low[1], low[2]);
    mat3 H1 = hessian(high[0], high[1], high[2]);
    double v1 = values(high[0], high[1], high[2]);
    scalar_function v(v0, v1);
    matrix_function h(H0, H1);
    double u = (point[dim]-low[dim])/(high[dim]-low[dim]);
    return std::make_pair(v(u), evmin(h(u)).first);
}

std::pair<int, std::vector<double>> process_edge(const EdgeID &e,
                                                    const BlockOfVectors &gradient,
                                                    const BlockOfMatrices &hessian,
                                                    const BlockOfScalars &data,
                                                    bool verbose = false,
                                                    const int sampling_res = 10,
                                                    const double min_value = 0,
                                                    const double min_strength = 1.0e-9,
                                                    const double min_criterion = 1.0e-9,
                                                    const double min_determinant = 1.0e-9)
{
    if (verbose) {
        std::cout << "\n\nprocessing edge " << e << '\n';
    }
    std::vector<double> solutions; // initially empty
    CoordID vs[2];
    vec3 gs[2];
    mat3 hs[2];
    double fs[2];
    double cs[2];
    double lmins[2];
    for (int i=0; i<2; ++i) {
        hs[i] = hessian(e[i][0], e[i][1], e[i][2]);
        gs[i] = gradient(e[i][0], e[i][1], e[i][2]);
        fs[i] = data(e[i][0], e[i][1], e[i][2]);
        cs[i] = determinant(gs[i], hs[i]);
        lmins[i] = evmin(hs[i]).first;
    }
    
    vector_function gfunc = vector_function(gs[0], gs[1]);
    matrix_function hfunc = matrix_function(hs[0], hs[1]);
    C0Criterion cfunc(gfunc, hfunc);
    
    if (verbose) 
    {
        std::cout << "\n";
        std::cout << "criterion: " << std::fabs(cs[0]) << ", " << std::fabs(cs[1]) << " (" << min_criterion << ")\n";
        std::cout << "hessian:   " << hs[0] << ", " << hs[1] << '\n'; 
        std::cout << "gradient:  " << gs[0] << ", " << gs[1] << '\n';
        std::cout << "values:    " << fs[0] << ", " << fs[1] << '\n';
        std::cout << "lmins:     " << lmins[0] << ", " << lmins[1] << std::endl;
    }

    // check if we are dealing with a degenerate case or one that
    // does not meet prescribed filtering criteria
    if (std::max(std::fabs(cs[0]), std::fabs(cs[1])) < min_criterion) 
    {
        return std::make_pair(criterion_underflow, solutions);
    }
    else if (std::max(lmins[0], lmins[1]) > -std::fabs(min_strength)) 
    {
        return std::make_pair(weak_ridge, solutions);
    }
    else if (std::max(fs[0], fs[1]) < min_value) 
    {
        return std::make_pair(low_ridge, solutions);
    }
    
    // initial uniform sampling
    std::vector<double> dets;
    double step = 1./double(sampling_res-1);
    for (double u=0; u<1+step; u+=step) 
    {
        dets.push_back(cfunc(u));
        if (verbose) 
        {
            std::cout << "det[" << u << "] = " << dets.back() << '\n';
        }
    }
    
    // adaptive zero-crossing search
    for (int i=0; i<dets.size()-1; ++i) 
    {
        double u0 = i*step;
        double u1 = u0 + step;
        const double& det0 = dets[i];
        const double& det1 = dets[i+1];
        if (det0 * det1 < 0) 
        {
            if (verbose) 
            {
                std::cout << "zero crossing found between " << u0 << " and " << u1 << '\n';
            }
            double u = find_zero_crossing(cfunc, u0, u1);
            if (verbose) 
            {
                std::cout << "zero crossing found at u=" << u << '\n';
            }
            if (u>=0 && check_solution(u, gfunc, hfunc, verbose)) 
            {
                solutions.push_back(u);
                if (verbose)
                    std::cout << "zero crossing found to be a ridge point\n";
            }
            else if (verbose) 
            {
                std::cout << "zero crossing is not a valid ridge point\n";
            }
        }
    }

    if (solutions.size() == 1) 
    {
        return std::make_pair(one_ridge_points, solutions);
    }
    else if (solutions.size() == 0) 
    {
        return std::make_pair(no_ridge_points, solutions); // code for nothing found
    }
    else 
    {
        return std::make_pair(several_ridge_points, solutions);
    }
}

template<typename T>
struct parser_traits;

template<>
struct parser_traits<int> 
{
    static std::regex get()
    {
        return std::regex("([-0-9]+)");
    }
    static int cast(const std::string& s) 
    {
        return std::stoi(s);
    }
};

template<>
struct parser_traits<double> 
{
    static std::regex get()
    {
        return std::regex("([+-]? *[0-9]+(\\.[0-9]+)?)");
    }
    static int cast(const std::string &s)
    {
        return std::stod(s);
    }
};

template<typename T=int>
void parse_values(std::vector<T>& out, const std::string& str, size_t n) 
{
    std::regex myregex = parser_traits<T>::get();
    auto begin = std::sregex_iterator(str.begin(), str.end(), myregex);
    auto end = std::sregex_iterator();
    std::cout << "Found " << std::distance(begin, end) << " values\n";
    if (std::distance(begin, end) == n)
    {
        int i = 0;
        for (std::sregex_iterator iter = begin; iter != end; ++iter, ++i)
        {
            std::smatch match = *iter;
            std::cout << "value=" << match.str() << std::endl;
            out.push_back(parser_traits<T>::cast(match.str()));
        }
    }
    else 
    {
        throw std::runtime_error("invalid input");
    }
}

void edge_neighbors(std::vector<CoordID>& neighbors, const EdgeID& eid) 
{
    CoordID i0 = eid[0];
    CoordID i1 = eid[1];
    int dim=0;
    for (int i=0; i<3; ++i) 
    {
        if (i0[i] != i1[i]) 
        {
            dim = i;
            break;
        }
    }
    neighbors.resize(4);
    int low = std::min(i0[dim], i1[dim]);
    CoordID ref = eid[0];
    ref[dim] = low;
    std::fill(neighbors.begin(), neighbors.end(), ref);
    neighbors[1][(dim+1)%3]--;
    neighbors[2][(dim+2)%3]--;
    neighbors[3][(dim+1)%3]--;
    neighbors[3][(dim+2)%3]--;
}

void grow_cluster(std::set<int>& cluster, int start, const dyn_mat_type& dist) 
{
    if (cluster.find(start) == cluster.end())
    {
        cluster.insert(start);
        for (int i=start+1; i<dist.cols(); ++i) {
            if (dist(start, i) == 1)
            {
                if (cluster.find(i) == cluster.end())
                {
                    grow_cluster(cluster, i, dist);
                }
            }
        }
    }
}

void find_neighbors(std::vector<std::vector<CoordID>>& neighbors, 
                    const std::map<CoordID, std::vector<int>, CoordLexico> voxels) 
{
    std::vector<CoordID> all_voxels;
    std::cout << "creating an array of voxels\n";
    for (auto iter=voxels.begin(); iter!=voxels.end(); ++iter)
    {
        all_voxels.push_back(iter->first);
    }
    int nvoxels = all_voxels.size();
    std::cout<< "done. creating a distance matrix\n";
    dyn_mat_type dist = dyn_mat_type::Zero(nvoxels, nvoxels);
    for (int i=0; i<nvoxels-1; ++i)
    {
        for (int j=i+1; j<nvoxels; ++j)
        {
            dist(i,j) = dist(j,i) = distance(all_voxels[i], all_voxels[j]);
        }
    }
    std::cout << "done.\n";
    std::vector<int> cluster_id(nvoxels, -1);
    for (int i=0; i<nvoxels; ++i)
    {
        if (cluster_id[i] >= 0) continue;
        std::set<int> acluster;
        acluster.insert(i);
        for (int j=i+1; j<nvoxels; ++j)
        {
            if (dist(i,j) == 1)
            {
                grow_cluster(acluster, j, dist);
            }
        }
        std::vector<CoordID> ids;
        std::for_each(acluster.begin(), acluster.end(), [&](int n) {
            ids.push_back(all_voxels[n]);
        });
        neighbors.push_back(ids);
        std::for_each(acluster.begin(), acluster.end(), [&](int n) {
            cluster_id[n] = neighbors.size()-1;
        });
    }
}

int main(int argc, const char* argv[]) 
{
    std::string data_name, gradient_name, hessian_name, output_name;
    double minval, minstr, eps, mind;
    int res, niter;
    bool verbose;
    CoordID voxel_id;
    std::pair<vec3, vec3> bounds;
    std::string voxel_str = "(-1, -1, -1)";
    std::string bounds_str = "(0, -1; 0, -1; 0, -1)";
    

    namespace cl = spurt::command_line;
    cl::option_traits
        required_group(true, false, "Required Options"),
        positional_group(true, true, "Positional Group"),
        optional_group(false, false, "Optional Group");

    cl::option_parser parser(argv[0],
                             "Extract ridge surfaces from scalar volume using\nPeikert and Sadlo's level set method");
    try 
    {
        parser.use_short_symbols(false);
        parser.use_brackets(true);

        parser.add_value("value", data_name, "Scalar raster filename", required_group);
        parser.add_value("gradient", gradient_name, "Gradient raster filename", required_group);
        parser.add_value("hessian", hessian_name, "Hessian raster filename", required_group);
        parser.add_value("output", output_name, "Output filename", required_group);
        parser.add_value("minval", minval, 0., "Min scalar value", optional_group);
        parser.add_value("minstr", minstr, 0., "Min ridge strength", optional_group);
        parser.add_value("eps", eps, 1.0e-9, "Numerical precision", optional_group);
        parser.add_value("mindist", mind, 0.02, "Min sampling distance", optional_group);
        parser.add_value("verbose", verbose, false, "Verbose output", optional_group);
        parser.add_value("res", res, 10, "Initial (coarse) sampling resolution to find ridge points", optional_group);
        parser.add_value("niter", niter, 100, "Max number of iterations of the zero crossing algorithm", optional_group);
        parser.add_value("voxel", voxel_str, voxel_str, "Coordinates of single voxel to process");
        parser.add_value("bounds", bounds_str, bounds_str, "Bounds of domain to consider");
        parser.parse(argc, argv);
    }
    catch (std::runtime_error &e)
    {
        std::cerr << "ERROR(1): " << argv[0] << " threw exception:\n"
                  << e.what() << "\n"
                  << "Command line options entered so far:\n"
                  << parser.print_self(false, true, false) << "\n\n\n";
        exit(1);
    }
    catch (std::exception &e)
    {
        std::cerr << "ERROR(2): " << argv[0] << " threw exception:\n"
                  << e.what() << "\n"
                  << "Command line options enteredso far:\n"
                  << parser.print_self(false, true, false) << "\n\n\n";
        exit(1);
    }

    {
        std::vector<int> iv;
        parse_values<int>(iv, voxel_str, 3);
        std::cout << iv << '\n';
        voxel_id = { iv[0], iv[1], iv[2] };

        std::vector<double> dv;
        parse_values<double>(dv, bounds_str, 6);
        std::cout << dv << '\n';
        bounds.first = { dv[0], dv[2], dv[4] };
        bounds.second = { dv[1], dv[3], dv[5] };
    }

    BlockOfScalars values;
    BlockOfVectors gradient;
    BlockOfMatrices hessian;
    import_nrrd(values, data_name);
    import_nrrd(gradient, gradient_name);
    import_nrrd(hessian, hessian_name);

    auto shape = values.shape();
    std::vector< CoordID > voxels;
    if (voxel_id[0] != -1)
    {
        voxels.clear();
        voxels.push_back(voxel_id);
        verbose = true;
    }
    else if (bounds.first[0] < bounds.second[0])
    {
        voxels.clear();
        const vec3& l = bounds.first;
        const vec3& h = bounds.second;
        CoordID low(static_cast<int>(l[0]), static_cast<int>(l[1]), static_cast<int>(l[2]));
        CoordID high(static_cast<int>(h[0]) + 1, static_cast<int>(h[1]) + 1, static_cast<int>(h[2]) + 1);
        for (int k=low[2]; k<=high[2]; ++k) 
        {
            for (int j=low[1]; j<=high[1]; ++j)
            {
                for (int i=low[0]; i<=high[0]; ++i) {
                    voxels.push_back(CoordID(i,j,k));
                }
            }
        }
    }
    else 
    {
        int _n = 0;
        voxels.resize((shape[0]-1)*(shape[1]-1)*(shape[2]-1));
        for (int k = 0; k < shape[2] - 1; ++k)
        {
            for (int j = 0; j < shape[1] - 1; ++j)
            {
                for (int i = 0; i < shape[0] - 1; ++i, ++_n)
                {
                    voxels[_n] = CoordID({{i, j, k}});
                }
            }
        }
    }
    std::cout << "There are " << voxels.size() << " voxels in input for a total of " << 12*voxels.size() << " (redundant) edges\n";

    std::map<EdgeID, std::vector<vec3> > all_processed_edges;
    int nskipped = 0;
    int nfailed_to_triangulate = 0;
    int nnot_enough_points = 0;
    int nsucceeded = 0;
    int nprocessed = 0;
    int nexcluded = 0;
    int nnone = 0;
    int neven = 0;
    int nweak = 0;
    int nlow = 0;
    int nunderflow = 0;
    int nfiltered = 0;
    // keep track of what triangles stem from what voxels to remove them 
    // if neededin case their containing voxels are subdivided. 
    std::map<CoordID, std::vector<int>, CoordLexico> voxel_to_triangles;
    std::vector<triangle_type> all_triangles;
    std::vector<vec4> rejected;

    if (voxel_id[0] != -1)
    {
        std::vector<mat3> H(8);
        std::vector<vec3> g(8);
        for (int i=0; i<8; ++i)
        {
            auto shift = vertices[i];
            CoordID pid = voxel_id + CoordID(shift[0], shift[1], shift[2]);
            H[i] = hessian(pid[0], pid[1], pid[2]);
            g[i] = gradient(pid[0], pid[1], pid[2]);
        }
        std::vector<double> det_values(2*101*101*101);
        for (int k=0; k<=100; ++k)
        {
            double z = k*0.01;
            double Z = 1.-z;
            for (int j=0; j<=100; ++j)
            {
                double y = j*0.01;
                double Y = 1.-y;
                for (int i=0; i<=100; ++i)
                {
                    double x = i*0.01;
                    double X = 1.-x;
                    mat3 theH = X * Y * Z * H[0] + x * Y * Z * H[1] + x * y * Z * H[2] + X * y * Z * H[3] +
                                X * Y * z * H[4] + x * Y * z * H[5] + x * y * z * H[6] + X * y * z * H[7];
                    vec3 theg = X * Y * Z * g[0] + x * Y * Z * g[1] + x * y * Z * g[2] + X * y * Z * g[3] +
                                X * Y * z * g[4] + x * Y * z * g[5] + x * y * z * g[6] + X * y * z * g[7];
                    det_values[2 * (i + 101 * (j + 101 * k))    ] = determinant(theg, theH);
                    det_values[2 * (i + 101 * (j + 101 * k)) + 1] = (project(theg, theH).first)[0];
                }
            }
        }
        size_t sizes[4] = {2, 101, 101, 101};
        std::ostringstream os;
        os << output_name << "_voxel_" << voxel_id[0] << "_" << voxel_id[1] << "_" << voxel_id[2] << ".nrrd";
        spurt::nrrd_utils::writeNrrd((void *)&det_values[0], os.str(), nrrdTypeDouble, 4, sizes);
    }

    spurt::ProgressDisplay progress;

    struct broken_voxel {
        CoordID id;
        std::vector<double> values;
        std::vector<double> strengths;
        std::vector<vec3> gradients;
        std::vector<mat3> hessians;
        std::map<int, std::vector<vec3> > edge_points;
    };
    std::vector<broken_voxel> broken_voxels;
    std::vector<EdgeID> double_edges;
    std::vector<CoordID> failed_voxels;
    std::vector<int> voxel_to_edge;
    std::map<CoordID, std::vector<int>, CoordLexico> voxel_counter;

    srand48(130819751900);
    progress.begin(voxels.size(), "Extract ridges", 10000, "tris: 0, done: 0, ok: 0, skip: 0, underflow: 0, weak: 0, low: 0, none: 0, even: 0, failed: 0");
    for (int n=0; n<voxels.size(); ++n) 
    {
        CoordID id = voxels[n];
        bool voxel_failed = false;
        // verbose = (id == CoordID(6, 14, 13));
        // verbose = (id[0] >= 150 && id[0] <= 160 && id[1] >= 60 && id[1] <= 75 && id[2] >= 60 && id[2] <=65);
        if (verbose)
        {
            std::cout << "processing voxel: " << id << '\n';
        }

        // check if current voxel satisfies threshold requirements
        std::vector<double> v_values(8);
        std::vector<double> s_values(8);
        for (int i=0; i<8; ++i)
        {
            auto shift = vertices[i];
            CoordID v = id + CoordID(shift[0], shift[1], shift[2]);
            v_values[i] = values(id[0], id[1], id[2]);
            auto h = hessian(id[0], id[1], id[2]);
            s_values[i] = evmin(h).first;
        }
        if ((*std::min_element(&s_values[0], &s_values[8]) > minstr) ||
            (*std::max_element(&v_values[0], &v_values[8]) < minval))
        {
            nnone++;
            continue;
        }

        // verbose = (id[0] >= 8 && id[0]<=10 && id[1]>=14 && id[1]<=19 && id[2]>=14 && id[2]<=17);
        std::map<int, std::vector<vec3>> found;
        std::string update_str = "tris: " + std::to_string(all_triangles.size()) + 
            ", ok: " + std::to_string(nsucceeded) + 
            ", skip: " + std::to_string(nskipped) + 
            // ", weak: " + std::to_string(nweak) +
            // ", low: " + std::to_string(nlow) +
            ", none: " + std::to_string(nnone) +
            ", failed: " + std::to_string(nfailed_to_triangulate) +
            ", insuf:" + std::to_string(nnot_enough_points);
        progress.update(n, update_str);
        std::ostringstream log;
        for (int i = 0; i < 12; ++i) 
        {
            CoordID v0 = id + CoordID(canonical_edge_coordinates[i][0]);
            CoordID v1 = id + CoordID(canonical_edge_coordinates[i][1]);
            EdgeID edgeid(v0, v1);
            auto iter = all_processed_edges.find(edgeid);
            if (iter != all_processed_edges.end())
            {   
                if (verbose) {
                    std::cout << "entry found for edge #" << i << " between " << v0 << " and " << v1 << '\n';
                    std::cout << "edge #" << i << " of voxel " << id << ": " << edgeid << " has already been processed\n";
                    std::cout << "map contains " << all_processed_edges.size() << " elements\n";
                }
                nskipped += 1;
                auto solutions = iter->second;
                if (!solutions.empty()) 
                {
                    found[i] = solutions;
                    if (verbose) {
                        std::cout << "This entry contains one or several ridge points\n";
                        std::cout << "Found now contains " << found.size() << " entries\n";
                    }
                }
                else {
                    if (verbose) {
                        std::cout << "This entry did not contain a ridge point\n";
                        std::cout << "Found now contains " << found.size() << " entries\n";
                    } 
                    continue;
                }
            }
            else 
            {
                if (verbose) 
                    std::cout << "\n\nedge #" << i << " of voxel " << id << ": " << edgeid << " is being processed" << '\n';
                // auto result = process_edge(edgeid, gradient, hessian, values, verbose, res, minval, minstr, eps, eps);
                auto result = analyze_edge(edgeid, gradient, hessian, values, verbose, res, 0.05, mind, minval, minstr, eps, eps);

                auto coordinates = result.second;
                if (!coordinates.empty()) {
                    if (coordinates.size() > 1) {
                        voxel_failed = true;
                        break;
                    }
                    found[i] = std::vector<vec3>();
                    if (verbose)
                        std::cout << "process_edge returned " << coordinates.size() << " solutions\n";
                    for (int k=0; k<coordinates.size(); ++k)
                    {
                        double u = coordinates[k];
                        found[i].push_back((1.-u)*vec3(edgeid[0].cast<double>()) + u*vec3(edgeid[1].cast<double>()));
                    }
                    if (verbose)
                        std::cout << "Found now contains " << found.size() << " entries\n";
                    all_processed_edges[edgeid] = found[i];
                }
                else if (result.first == criterion_underflow) 
                {
                    if (verbose)
                        std::cout << "criterion underflow\n";
                    nunderflow++;
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == weak_ridge) 
                {
                    if (verbose)
                        std::cout << "weak ridge\n";
                    nweak++;
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == low_ridge) 
                {
                    if (verbose)
                        std::cout << "low ridge\n";
                    nlow++;
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == no_ridge_points) 
                {
                    if (verbose)
                        std::cout << "no ridge point\n";
                    nnone++;
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else 
                {
                    if (verbose)
                        std::cout << "unrecognized case\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                nprocessed++;
            }
        }
        if (voxel_failed)
        {
            failed_voxels.push_back(id);
            continue;
        }
        else if (found.size() >= 3) 
        {
            if (verbose) 
            {
                std::cout << "After looking at all edges found contains " << found.size() << " entries\n";
                for (auto iter = found.begin(); iter!=found.end(); ++iter)
                {
                    std::cout << "Edge #" << iter->first << " contains " << iter->second << '\n';
                    for (auto jter=iter->second.begin(); jter!=iter->second.end(); ++jter) {
                        auto r = evaluate(*jter, values, hessian);
                        std::cout << "ridge point at " << *jter << " has value " << r.first << " and ridge strength " << r.second << '\n';
                    }
                }
            }
            std::vector<triangle_type> tris;
            int tri_case;
            if (verbose)
                tri_case = triangulate(tris, found, std::cout);
            else
                tri_case = triangulate(tris, found, log);

            if (tris.size() > 0) 
            {
                std::for_each(tris.begin(), tris.end(), [&](auto T) 
                {
                    all_triangles.push_back(T);
                });
                nsucceeded++;
            }
            else 
            {
                if (verbose)
                    std::cout << "Triangulation failed\n";
                nfailed_to_triangulate++;
                failed_voxels.push_back(id);
                continue;
            }
        }
        else if (found.size() > 0) 
        {
            nnot_enough_points++;
            failed_voxels.push_back(id);
            continue;
        }
    }
    std::cout << "There were " << failed_voxels.size() << " failed voxels\n";

    std::vector<vec3> all_edge_points;
    for (auto iter=all_processed_edges.begin(); iter!=all_processed_edges.end(); ++iter)
    {
        auto pts = iter->second;
        if (pts.empty())
            continue;
        all_edge_points.insert(all_edge_points.end(), pts.begin(), pts.end());
    }
    {
        size_t sizes[3] = { 3, all_edge_points.size() };
        spurt::nrrd_utils::writeNrrd((void*)&all_edge_points[0], output_name + "_all_points.nrrd", 
                                     nrrdTypeDouble, 2, sizes);
    }

    progress.end();
    int nfailed = 0;
    int nfixed = 0;
    progress.begin(failed_voxels.size(), "Repair ridges", 10000, "tris: 0, done: 0, ok: 0, skip: 0, underflow: 0, weak: 0, low: 0, none: 0, even: 0, failed: 0");
    for (int n = 0; n < failed_voxels.size(); ++n)
    {
        CoordID id = failed_voxels[n];
        std::map<int, std::vector<vec3>> found;
        std::string update_str = "fixed: " + std::to_string(nfixed) +
                                 ", failed: " + std::to_string(nfailed);
        progress.update(n, update_str);
        std::ostringstream log;
        for (int i = 0; i < 12; ++i)
        {
            CoordID v0 = id + CoordID(canonical_edge_coordinates[i][0]);
            CoordID v1 = id + CoordID(canonical_edge_coordinates[i][1]);
            EdgeID edgeid(v0, v1);
            auto iter = all_processed_edges.find(edgeid);
            assert(iter != all_processed_edges.end());
            auto solutions = iter->second;
            if (!verbose && !solutions.empty()) {
                found[i] = solutions;
            }
            else
            {
                if (verbose)
                    std::cout << "\n\nedge #" << i << " of voxel " << id << ": " << edgeid << " is being reprocessed" << '\n';
                auto result = process_edge(edgeid, gradient, hessian, values, verbose, 10*res, minval, minstr, eps, eps);
                auto coordinates = result.second;
                if (!coordinates.empty())
                {
                    found[i] = std::vector<vec3>();
                    if (verbose)
                        std::cout << "process_edge returned " << coordinates.size() << " solutions\n";
                    for (int k = 0; k < coordinates.size(); ++k)
                    {
                        double u = coordinates[k];
                        found[i].push_back((1. - u) * vec3(edgeid[0].cast<double>()) + u * vec3(edgeid[1].cast<double>()));
                    }
                    if (verbose)
                        std::cout << "Found now contains " << found.size() << " entries\n";
                    all_processed_edges[edgeid] = found[i];
                }
                else if (result.first == criterion_underflow)
                {
                    if (verbose)
                        std::cout << "criterion underflow\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == weak_ridge)
                {
                    if (verbose)
                        std::cout << "weak ridge\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == low_ridge)
                {
                    if (verbose)
                        std::cout << "low ridge\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else if (result.first == no_ridge_points)
                {
                    if (verbose)
                        std::cout << "no ridge point\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                else
                {
                    if (verbose)
                        std::cout << "unrecognized case\n";
                    all_processed_edges[edgeid] = std::vector<vec3>();
                }
                nprocessed++;
            }
        }

        if (found.size() >= 3)
        {
            if (verbose)
            {
                std::cout << "After looking at all edges found contains " << found.size() << " entries\n";
                for (auto iter = found.begin(); iter != found.end(); ++iter)
                {
                    std::cout << "Edge #" << iter->first << " contains " << iter->second << '\n';
                }
            }
            std::vector<triangle_type> tris;
            int tri_case;
            if (verbose)
                tri_case = triangulate(tris, found, std::cout);
            else
                tri_case = triangulate(tris, found, log);

            if (tris.size() > 0)
            {
                std::for_each(tris.begin(), tris.end(), [&](auto T)
                              {
                                  all_triangles.push_back(T);
                                  // std::cout << "\nTriangle is " << T << '\n';
                              });
                nfixed++;
            }
            else
            {
                if (verbose)
                    std::cout << "Triangulation failed\n";
                nfailed++;
            }
        }
        else if (found.size() > 0)
        {
            nfailed++;
        }
        else
        {
            nfailed++;
        }
    }
    progress.end();
    std::cout << nfixed << " / " << failed_voxels.size() << " broken voxels were fixed\n";

    if (!all_triangles.empty()) 
    {
        size_t sizes[3] = { 3, 3, all_triangles.size() };
        spurt::nrrd_utils::writeNrrd((void*)&all_triangles[0], output_name + "_mesh.nrrd", 
                                     nrrdTypeDouble, 3, sizes);
        std::vector<std::array<double, 2>> attributes(3*all_triangles.size());
        std::cout << "interpolating value and ridge strength...\n";
        std::cout << "there are " << all_triangles.size() << " triangles\n";
        for (size_t n=0; n<all_triangles.size(); ++n)
        {
            auto tri = all_triangles[n];
            for (int k=0; k<3; ++k)
            {
                auto p = tri[k];
                // compute value and ridge strength at that position
                auto v = values.evaluate(p);
                auto h = hessian.evaluate(p);
                auto l3_ev3 = evmin(h);
                attributes[3*n+k] = {v, l3_ev3.first};
            }
        }
        std::cout << "\ndone\n";
        sizes[0] = 2;
        spurt::nrrd_utils::writeNrrd((void*)&attributes[0], output_name + "_attributes.nrrd",
                                     nrrdTypeDouble, 3, sizes);
    }
    else 
    {
        std::cout << "No triangles found\n";
    }

    if (!rejected.empty()) 
    {
        size_t sizes[2] = { 4, rejected.size() };
        spurt::nrrd_utils::writeNrrd((void*)&rejected[0], "rejected.nrrd", nrrdTypeDouble, 2, sizes);
    }
    else 
    {
        std::cout << "No rejected points\n";
    }

    if (false && !broken_voxels.empty()) {
        std::cout << "There were " << broken_voxels.size() << " broken voxels (" << nfailed_to_triangulate << ")\n";
        std::ofstream output("broken_voxels.txt");
        for (int n=0; n<broken_voxels.size(); ++n) 
        {
            const broken_voxel& voxel = broken_voxels[n];
            output << "Broken voxel #" << voxel.id << '\n';
            output << "    * values:\n";
            for (int k=0; k<8; ++k) {
                output << "        [" << k << "]: " << std::scientific << voxel.values[k] << '\n';
            }
            output << "    * gradients:\n";
            for (int k=0; k<8; ++k) {
                const vec3& g = voxel.gradients[k];
                output << "        [" << k << "]: [" << std::scientific << g[0] << ", " << g[1] << ", " << g[2] << "]\n";
            }
            output << "    * hessians:\n";
            for (int k = 0; k < 8; ++k)
            {
                const mat3 &h = voxel.hessians[k];
                output << "        [" << k << "]: [" << std::scientific
                       << "[" << h(0, 0) << ", " << h(0, 1) << ", " << h(0, 2) << "], "
                       << "[" << h(1, 0) << ", " << h(1, 1) << ", " << h(1, 2) << "], "
                       << "[" << h(2, 0) << ", " << h(2, 1) << ", " << h(2, 2) << "]]\n";

            }
            output << "    * strengths:\n";
            for (int k=0; k<8; ++k)
            {
                const double& s = voxel.strengths[k];
                output << "        [" << k << "]: " << std::scientific << s << '\n'; 
            }
            output << "    * edge points:\n";
            for (auto iter=voxel.edge_points.begin(); iter!=voxel.edge_points.end(); ++iter) {
                output << "        [" << iter->first << "]: [";
                for (int k=0; k<iter->second.size(); ++k) {
                    const vec3& p = iter->second[k];
                    output << std::scientific
                        << "[" << p[0] << ", " << p[1] << ", " << p[2] << "], ";
                } 
                output << "]\n";
            }
            output << "\n";
        }
        output.close();
    }

    return 0;
}
